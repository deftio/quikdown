<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plugin Guide - quikdown Documentation</title>
    <link rel="stylesheet" href="https://unpkg.com/github-markdown-css@5/github-markdown.css">
    <link rel="stylesheet" href="https://unpkg.com/prismjs@1/themes/prism.css">
    <style>
        body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
        }
        @media (max-width: 767px) {
            body { padding: 15px; }
        }
        /* Ensure emojis display properly */
        .markdown-body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
        }
        /* Code block styling */
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 16px;
            overflow: auto;
        }
        code {
            background-color: rgba(175, 184, 193, 0.2);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 85%;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        /* Table styling */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 16px;
            margin-bottom: 16px;
        }
        table th, table td {
            border: 1px solid #d0d7de;
            padding: 6px 13px;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
    </style>
    <script src="https://unpkg.com/prismjs@1/components/prism-core.min.js"></script>
    <script src="https://unpkg.com/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>
    <article class="markdown-body">
        <h1>Plugin Development Guide</h1>
<h2>Overview</h2>
<p>quikdown&#39;s plugin system allows you to customize how fenced code blocks are rendered. This enables syntax highlighting, diagrams, math rendering, custom components, and even trusted HTML rendering.</p>
<h2>Basic Plugin Structure</h2>
<p>A fence plugin is a function that receives code block content and returns HTML:</p>
<pre><code class="language-javascript">function myPlugin(content, language) {
  // content: Raw, unescaped content from the code block
  // language: The language identifier (or empty string)
  
  // Return HTML string to render, or undefined to use default
  return &#39;&lt;div&gt;Custom HTML&lt;/div&gt;&#39;;
}
</code></pre>
<h2>Plugin Contract</h2>
<h3>Input Parameters</h3>
<ol>
<li><p><strong><code>content</code></strong> (string)</p>
<ul>
<li>Raw content from the fence block</li>
<li><strong>NOT HTML-escaped</strong> when plugin is active</li>
<li>Trimmed of trailing whitespace</li>
<li>Preserves internal spacing and newlines</li>
</ul>
</li>
<li><p><strong><code>language</code></strong> (string)</p>
<ul>
<li>Language identifier after <code>```</code></li>
<li>Empty string if no language specified</li>
<li>Can be any string (not limited to programming languages)</li>
</ul>
</li>
</ol>
<h3>Return Values</h3>
<ul>
<li><strong><code>string</code></strong> - HTML to render (you&#39;re responsible for escaping!)</li>
<li><strong><code>undefined</code></strong> - Fall back to default code block rendering</li>
</ul>
<h2>Simple Examples</h2>
<h3>Hello World Plugin</h3>
<pre><code class="language-javascript">function helloPlugin(content, language) {
  if (language === &#39;hello&#39;) {
    return `&lt;div class=&quot;greeting&quot;&gt;Hello, ${content}!&lt;/div&gt;`;
  }
  return undefined; // Use default for other languages
}

// Usage in markdown:
// ```hello
// World
// ```
// Output: &lt;div class=&quot;greeting&quot;&gt;Hello, World!&lt;/div&gt;
</code></pre>
<h3>JSON Viewer</h3>
<pre><code class="language-javascript">function jsonPlugin(content, language) {
  if (language === &#39;json&#39;) {
    try {
      const data = JSON.parse(content);
      const pretty = JSON.stringify(data, null, 2);
      return `&lt;pre class=&quot;json-viewer&quot;&gt;${escapeHtml(pretty)}&lt;/pre&gt;`;
    } catch (e) {
      return `&lt;pre class=&quot;json-error&quot;&gt;Invalid JSON: ${e.message}&lt;/pre&gt;`;
    }
  }
}
</code></pre>
<h2>Advanced Examples</h2>
<h3>Syntax Highlighting with Prism.js</h3>
<pre><code class="language-javascript">function prismPlugin(content, language) {
  // Check if Prism supports this language
  if (language &amp;&amp; Prism.languages[language]) {
    const highlighted = Prism.highlight(
      content,
      Prism.languages[language],
      language
    );
    return `&lt;pre class=&quot;language-${language}&quot;&gt;&lt;code&gt;${highlighted}&lt;/code&gt;&lt;/pre&gt;`;
  }
  // Fall back to default for unsupported languages
  return undefined;
}
</code></pre>
<h3>Mermaid Diagrams</h3>
<pre><code class="language-javascript">function mermaidPlugin(content, language) {
  if (language === &#39;mermaid&#39;) {
    // Generate unique ID for async rendering
    const id = &#39;mermaid-&#39; + Math.random().toString(36).substr(2, 9);
    
    // Return placeholder that will be replaced
    return `
      &lt;div id=&quot;${id}&quot; class=&quot;mermaid-container&quot;&gt;
        &lt;pre class=&quot;mermaid-source&quot; style=&quot;display:none&quot;&gt;${escapeHtml(content)}&lt;/pre&gt;
        &lt;div class=&quot;mermaid-rendering&quot;&gt;Rendering diagram...&lt;/div&gt;
      &lt;/div&gt;
      &lt;script&gt;
        (function() {
          const element = document.getElementById(&#39;${id}&#39;);
          const source = element.querySelector(&#39;.mermaid-source&#39;).textContent;
          mermaid.render(&#39;${id}-svg&#39;, source).then(result =&gt; {
            element.querySelector(&#39;.mermaid-rendering&#39;).innerHTML = result.svg;
          }).catch(error =&gt; {
            element.querySelector(&#39;.mermaid-rendering&#39;).innerHTML = 
              &#39;&lt;div class=&quot;error&quot;&gt;Failed to render diagram: &#39; + error + &#39;&lt;/div&gt;&#39;;
          });
        })();
      &lt;/script&gt;
    `;
  }
}
</code></pre>
<h3>Math with KaTeX</h3>
<pre><code class="language-javascript">function mathPlugin(content, language) {
  if (language === &#39;math&#39; || language === &#39;latex&#39;) {
    try {
      const html = katex.renderToString(content, {
        displayMode: true,
        throwOnError: false,
        errorColor: &#39;#cc0000&#39;
      });
      return `&lt;div class=&quot;math-block&quot;&gt;${html}&lt;/div&gt;`;
    } catch (e) {
      return `&lt;div class=&quot;math-error&quot;&gt;Invalid math: ${escapeHtml(e.message)}&lt;/div&gt;`;
    }
  }
}
</code></pre>
<h3>Custom Components</h3>
<pre><code class="language-javascript">function componentPlugin(content, language) {
  if (language === &#39;component&#39;) {
    try {
      const config = JSON.parse(content);
      
      // Validate component type
      if (![&#39;alert&#39;, &#39;card&#39;, &#39;tabs&#39;].includes(config.type)) {
        throw new Error(`Unknown component type: ${config.type}`);
      }
      
      // Render based on type
      switch (config.type) {
        case &#39;alert&#39;:
          return `
            &lt;div class=&quot;alert alert-${config.level || &#39;info&#39;}&quot;&gt;
              ${escapeHtml(config.message)}
            &lt;/div&gt;
          `;
          
        case &#39;card&#39;:
          return `
            &lt;div class=&quot;card&quot;&gt;
              &lt;h3&gt;${escapeHtml(config.title)}&lt;/h3&gt;
              &lt;p&gt;${escapeHtml(config.content)}&lt;/p&gt;
            &lt;/div&gt;
          `;
          
        default:
          return `&lt;div&gt;Unsupported component&lt;/div&gt;`;
      }
    } catch (e) {
      return `&lt;div class=&quot;component-error&quot;&gt;Invalid component: ${escapeHtml(e.message)}&lt;/div&gt;`;
    }
  }
}

// Usage:
// ```component
// {
//   &quot;type&quot;: &quot;alert&quot;,
//   &quot;level&quot;: &quot;warning&quot;,
//   &quot;message&quot;: &quot;This is a warning!&quot;
// }
// ```
</code></pre>
<h2>Security Considerations</h2>
<h3>⚠️ Critical: Escape User Content</h3>
<p>Plugins receive <strong>raw, unescaped content</strong>. You MUST escape it unless you explicitly trust it:</p>
<pre><code class="language-javascript">// ❌ DANGEROUS - XSS vulnerability!
function badPlugin(content, language) {
  return `&lt;div&gt;${content}&lt;/div&gt;`; // content could contain &lt;script&gt;!
}

// ✅ SAFE - Content is escaped
function goodPlugin(content, language) {
  return `&lt;div&gt;${escapeHtml(content)}&lt;/div&gt;`;
}

// Helper function
function escapeHtml(text) {
  const map = {
    &#39;&amp;&#39;: &#39;&amp;amp;&#39;,
    &#39;&lt;&#39;: &#39;&amp;lt;&#39;,
    &#39;&gt;&#39;: &#39;&amp;gt;&#39;,
    &#39;&quot;&#39;: &#39;&amp;quot;&#39;,
    &quot;&#39;&quot;: &#39;&amp;#39;&#39;
  };
  return text.replace(/[&amp;&lt;&gt;&quot;&#39;]/g, m =&gt; map[m]);
}
</code></pre>
<h3>Trusted HTML Rendering</h3>
<p>If you need to render trusted HTML:</p>
<pre><code class="language-javascript">function trustedHtmlPlugin(content, language) {
  // Only allow for specific, trusted sources
  if (language === &#39;html-preview&#39; &amp;&amp; isAdminUser()) {
    // Sanitize even trusted content for defense-in-depth
    return DOMPurify.sanitize(content, {
      ALLOWED_TAGS: [&#39;div&#39;, &#39;span&#39;, &#39;p&#39;, &#39;a&#39;, &#39;img&#39;],
      ALLOWED_ATTR: [&#39;class&#39;, &#39;href&#39;, &#39;src&#39;, &#39;alt&#39;]
    });
  }
}
</code></pre>
<h3>Validation Best Practices</h3>
<p>Always validate and sanitize:</p>
<pre><code class="language-javascript">function robustPlugin(content, language) {
  // 1. Check language
  if (![&#39;myformat&#39;].includes(language)) {
    return undefined;
  }
  
  // 2. Validate content
  if (content.length &gt; 10000) {
    return &#39;&lt;div class=&quot;error&quot;&gt;Content too large&lt;/div&gt;&#39;;
  }
  
  // 3. Parse safely
  try {
    const data = parseContent(content);
    
    // 4. Validate parsed data
    if (!isValidData(data)) {
      throw new Error(&#39;Invalid data format&#39;);
    }
    
    // 5. Escape when rendering
    return renderData(data, escapeHtml);
    
  } catch (error) {
    // 6. Safe error handling
    return `&lt;div class=&quot;error&quot;&gt;${escapeHtml(error.message)}&lt;/div&gt;`;
  }
}
</code></pre>
<h2>Multi-Language Plugin</h2>
<p>Handle multiple languages in one plugin:</p>
<pre><code class="language-javascript">function multiPlugin(content, language) {
  switch (language) {
    case &#39;graph&#39;:
      return renderGraph(content);
      
    case &#39;music&#39;:
      return renderMusicNotation(content);
      
    case &#39;csv&#39;:
      return renderCSVTable(content);
      
    case &#39;diff&#39;:
      return renderDiff(content);
      
    default:
      // Check if it&#39;s a programming language
      if (Prism.languages[language]) {
        return renderSyntaxHighlight(content, language);
      }
      
      // Fall back to default
      return undefined;
  }
}
</code></pre>
<h2>Async Rendering</h2>
<p>For async operations, return a placeholder and update later:</p>
<pre><code class="language-javascript">function asyncPlugin(content, language) {
  if (language === &#39;async-content&#39;) {
    const id = &#39;async-&#39; + Date.now();
    
    // Schedule async operation
    setTimeout(() =&gt; {
      fetchContent(content).then(result =&gt; {
        const element = document.getElementById(id);
        if (element) {
          element.innerHTML = result;
        }
      });
    }, 0);
    
    // Return placeholder immediately
    return `&lt;div id=&quot;${id}&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;`;
  }
}
</code></pre>
<h2>Error Handling</h2>
<p>Always handle errors gracefully:</p>
<pre><code class="language-javascript">function safePlugin(content, language) {
  try {
    // Attempt to process
    return processContent(content, language);
    
  } catch (error) {
    // Log for debugging
    console.error(`Plugin error for language &#39;${language}&#39;:`, error);
    
    // Return safe error message
    return `
      &lt;div class=&quot;plugin-error&quot;&gt;
        &lt;strong&gt;Error rendering ${escapeHtml(language)} block:&lt;/strong&gt;
        &lt;pre&gt;${escapeHtml(error.message)}&lt;/pre&gt;
      &lt;/div&gt;
    `;
  }
}
</code></pre>
<h2>Testing Plugins</h2>
<h3>Unit Testing</h3>
<pre><code class="language-javascript">describe(&#39;myPlugin&#39;, () =&gt; {
  test(&#39;renders correct language&#39;, () =&gt; {
    const result = myPlugin(&#39;content&#39;, &#39;mylang&#39;);
    expect(result).toContain(&#39;content&#39;);
  });
  
  test(&#39;returns undefined for unknown language&#39;, () =&gt; {
    const result = myPlugin(&#39;content&#39;, &#39;unknown&#39;);
    expect(result).toBeUndefined();
  });
  
  test(&#39;escapes HTML in content&#39;, () =&gt; {
    const result = myPlugin(&#39;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#39;, &#39;mylang&#39;);
    expect(result).not.toContain(&#39;&lt;script&gt;&#39;);
    expect(result).toContain(&#39;&amp;lt;script&amp;gt;&#39;);
  });
  
  test(&#39;handles errors gracefully&#39;, () =&gt; {
    const result = myPlugin(&#39;invalid{{content&#39;, &#39;mylang&#39;);
    expect(result).toContain(&#39;error&#39;);
    expect(result).not.toThrow();
  });
});
</code></pre>
<h3>Integration Testing</h3>
<pre><code class="language-javascript">test(&#39;plugin works with quikdown&#39;, () =&gt; {
  const markdown = &#39;```mylang\ntest content\n```&#39;;
  const html = quikdown(markdown, { fence_plugin: myPlugin });
  expect(html).toContain(&#39;test content&#39;);
});
</code></pre>
<h2>Performance Tips</h2>
<h3>1. Early Returns</h3>
<pre><code class="language-javascript">function fastPlugin(content, language) {
  // Check language first (fast)
  if (language !== &#39;mylang&#39;) return undefined;
  
  // Then validate content (slower)
  if (!isValid(content)) return undefined;
  
  // Finally process (slowest)
  return process(content);
}
</code></pre>
<h3>2. Cache Expensive Operations</h3>
<pre><code class="language-javascript">const cache = new Map();

function cachedPlugin(content, language) {
  if (language !== &#39;expensive&#39;) return undefined;
  
  const key = `${language}:${content}`;
  if (cache.has(key)) {
    return cache.get(key);
  }
  
  const result = expensiveOperation(content);
  cache.set(key, result);
  return result;
}
</code></pre>
<h3>3. Limit Content Size</h3>
<pre><code class="language-javascript">function limitedPlugin(content, language) {
  if (content.length &gt; 50000) {
    return &#39;&lt;div class=&quot;error&quot;&gt;Content too large&lt;/div&gt;&#39;;
  }
  return processContent(content, language);
}
</code></pre>
<h2>Plugin Composition</h2>
<p>Combine multiple plugins:</p>
<pre><code class="language-javascript">function combinePlugins(...plugins) {
  return (content, language) =&gt; {
    for (const plugin of plugins) {
      const result = plugin(content, language);
      if (result !== undefined) {
        return result;
      }
    }
    return undefined;
  };
}

// Usage
const myPlugin = combinePlugins(
  syntaxPlugin,
  diagramPlugin,
  mathPlugin,
  customPlugin
);
</code></pre>
<h2>Debugging Plugins</h2>
<p>Add debug output:</p>
<pre><code class="language-javascript">function debugPlugin(content, language) {
  console.group(`Plugin called: ${language}`);
  console.log(&#39;Content length:&#39;, content.length);
  console.log(&#39;First 100 chars:&#39;, content.substring(0, 100));
  
  try {
    const result = actualPlugin(content, language);
    console.log(&#39;Result:&#39;, result ? &#39;HTML generated&#39; : &#39;undefined&#39;);
    console.groupEnd();
    return result;
  } catch (error) {
    console.error(&#39;Plugin error:&#39;, error);
    console.groupEnd();
    throw error;
  }
}
</code></pre>
<h2>Real-World Example: Complete Plugin</h2>
<p>Here&#39;s a production-ready plugin example:</p>
<pre><code class="language-javascript">/**
 * Advanced code block plugin with multiple features
 */
function advancedCodePlugin(content, language) {
  // Configuration
  const config = {
    maxSize: 100000,
    supportedLanguages: [&#39;js&#39;, &#39;python&#39;, &#39;html&#39;, &#39;css&#39;, &#39;json&#39;, &#39;markdown&#39;],
    enableLineNumbers: true,
    enableCopy: true
  };
  
  // Early return for unsupported languages
  if (!config.supportedLanguages.includes(language)) {
    return undefined;
  }
  
  // Size check
  if (content.length &gt; config.maxSize) {
    return `&lt;div class=&quot;code-error&quot;&gt;Code too large (${content.length} chars)&lt;/div&gt;`;
  }
  
  // Generate unique ID
  const id = &#39;code-&#39; + Math.random().toString(36).substr(2, 9);
  
  // Process content
  let processedContent;
  try {
    if (typeof Prism !== &#39;undefined&#39; &amp;&amp; Prism.languages[language]) {
      // Syntax highlighting available
      processedContent = Prism.highlight(content, Prism.languages[language], language);
    } else {
      // No highlighting, escape HTML
      processedContent = escapeHtml(content);
    }
  } catch (error) {
    return `&lt;div class=&quot;code-error&quot;&gt;Highlighting failed: ${escapeHtml(error.message)}&lt;/div&gt;`;
  }
  
  // Build HTML
  let html = `&lt;div class=&quot;code-block&quot; id=&quot;${id}&quot;&gt;`;
  
  // Header with language and copy button
  html += `
    &lt;div class=&quot;code-header&quot;&gt;
      &lt;span class=&quot;code-language&quot;&gt;${escapeHtml(language)}&lt;/span&gt;
      ${config.enableCopy ? `
        &lt;button class=&quot;code-copy&quot; onclick=&quot;copyCode(&#39;${id}&#39;)&quot;&gt;
          Copy
        &lt;/button&gt;
      ` : &#39;&#39;}
    &lt;/div&gt;
  `;
  
  // Code content with optional line numbers
  if (config.enableLineNumbers) {
    const lines = content.split(&#39;\n&#39;);
    const lineNumbers = lines.map((_, i) =&gt; i + 1).join(&#39;\n&#39;);
    html += `
      &lt;div class=&quot;code-content&quot;&gt;
        &lt;pre class=&quot;line-numbers&quot;&gt;${lineNumbers}&lt;/pre&gt;
        &lt;pre class=&quot;language-${language}&quot;&gt;&lt;code&gt;${processedContent}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
    `;
  } else {
    html += `
      &lt;pre class=&quot;language-${language}&quot;&gt;&lt;code&gt;${processedContent}&lt;/code&gt;&lt;/pre&gt;
    `;
  }
  
  html += &#39;&lt;/div&gt;&#39;;
  
  return html;
}

// Helper function (should be in global scope)
window.copyCode = function(id) {
  const element = document.getElementById(id);
  const code = element.querySelector(&#39;code&#39;).textContent;
  navigator.clipboard.writeText(code).then(() =&gt; {
    const button = element.querySelector(&#39;.code-copy&#39;);
    button.textContent = &#39;Copied!&#39;;
    setTimeout(() =&gt; {
      button.textContent = &#39;Copy&#39;;
    }, 2000);
  });
};
</code></pre>
<h2>Summary</h2>
<p>Key points for plugin development:</p>
<ol>
<li><strong>Always escape user content</strong> unless explicitly trusted</li>
<li><strong>Return <code>undefined</code></strong> to fall back to default rendering</li>
<li><strong>Handle errors gracefully</strong> - never throw</li>
<li><strong>Validate input</strong> before processing</li>
<li><strong>Keep plugins focused</strong> - one plugin per concern</li>
<li><strong>Test thoroughly</strong> - including security and edge cases</li>
<li><strong>Document requirements</strong> - what libraries/setup needed</li>
<li><strong>Consider performance</strong> - cache expensive operations</li>
<li><strong>Provide feedback</strong> - loading states, error messages</li>
<li><strong>Be defensive</strong> - assume content could be malicious</li>
</ol>

    </article>
    <script>
        // Syntax highlighting
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    </script>
</body>
</html>