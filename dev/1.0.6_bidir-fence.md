# Bidirectional Fence Plugin API - Implementation Notes v1.0.6

## Executive Summary

This document details the implementation of a **100% backwards-compatible** bidirectional fence plugin API that allows custom fence handlers to define how to convert their HTML output back to markdown. This enables perfect roundtrip conversion for custom content types while maintaining full compatibility with all existing fence plugins.

## Problem Statement

Currently, fence plugins can only define the forward conversion (markdown → HTML):

```javascript
// Current API - one way only
fence_plugin: (content, lang) => '<div>custom html</div>'
```

When converting HTML back to markdown, quikdown_bd has no way to know how to reverse custom HTML structures, leading to:
- Loss of original fence language/type
- Incorrect extraction of content
- Broken roundtrip for custom visualizations (SVG, Mermaid, Math, etc.)

## Solution Overview

Allow fence plugins to optionally provide a reverse handler while maintaining 100% backwards compatibility:

```javascript
// Option 1: Object format (recommended)
fence_plugin: {
  render: (content, lang) => html,     // markdown → HTML
  reverse: (element) => {...}          // HTML → markdown
}

// Option 2: Function with property
fence_plugin: function(content, lang) { return html; }
fence_plugin.reverse = (element) => {...}

// Option 3: Simple function (existing - still works!)
fence_plugin: (content, lang) => html
```

## Detailed Implementation

### 1. Core Helper Functions (goes in quikdown.js)

```javascript
// Add at module level in quikdown.js (around line 60)

/**
 * Check if a plugin is the extended object format
 */
function isExtendedFencePlugin(plugin) {
  return plugin && typeof plugin === 'object' && typeof plugin.render === 'function';
}

/**
 * Get the render function from any plugin format
 * @returns {Function|null} The render function or null
 */
function getFenceRenderer(plugin) {
  if (!plugin) return null;
  if (typeof plugin === 'function') return plugin;
  if (isExtendedFencePlugin(plugin)) return plugin.render;
  return null;
}

/**
 * Get the reverse function if available
 * @returns {Function|null} The reverse function or null
 */
function getFenceReverser(plugin) {
  if (!plugin) return null;
  // Check function with .reverse property
  if (typeof plugin === 'function' && plugin.reverse) return plugin.reverse;
  // Check object format
  if (isExtendedFencePlugin(plugin) && plugin.reverse) return plugin.reverse;
  return null;
}
```

### 2. Update Fence Processing in quikdown.js

```javascript
// Around line 140, update the fence extraction:

html = html.replace(/^(```|~~~)([^\n]*)\n([\s\S]*?)^\1$/gm, (match, fence, lang, code) => {
    const placeholder = `${PLACEHOLDER_CB}${codeBlocks.length}§`;
    const langTrimmed = lang ? lang.trim() : '';
    
    // Get the renderer function (handles all formats)
    const renderer = getFenceRenderer(fence_plugin);
    
    if (renderer) {
        codeBlocks.push({
            lang: langTrimmed,
            code: code.trimEnd(),
            custom: true,
            fence: fence,
            hasReverser: !!getFenceReverser(fence_plugin)  // Track if reverser available
        });
    } else {
        codeBlocks.push({
            lang: langTrimmed,
            code: escapeHtml(code.trimEnd()),
            custom: false,
            fence: fence,
            hasReverser: false
        });
    }
    return placeholder;
});

// Around line 300, update fence restoration:

codeBlocks.forEach((block, i) => {
    let replacement;
    
    if (block.custom && fence_plugin) {
        // Get renderer (handles all plugin formats)
        const renderer = getFenceRenderer(fence_plugin);
        replacement = renderer(block.code, block.lang);
        
        // If plugin returns undefined, fall back to default
        if (replacement === undefined) {
            const langClass = !inline_styles && block.lang ? ` class="language-${block.lang}"` : '';
            const langAttr = block.lang ? ` data-qd-lang="${block.lang}"` : '';
            replacement = `<pre${getAttr('pre')}${dataQd(block.fence)}${langAttr}><code${langClass}>${block.code}</code></pre>`;
        } else if (bidirectional) {
            // Add metadata for roundtrip if reverser available
            if (block.hasReverser) {
                // Mark that this has a custom reverser
                replacement = replacement.replace(
                    /^<(\w+)/,
                    `<$1 data-qd-fence="${block.fence}" data-qd-lang="${block.lang}" data-qd-has-reverser="true"`
                );
            }
            // Always store source for fallback
            replacement = replacement.replace(
                /^<(\w+)/,
                `<$1 data-qd-source="${escapeHtml(block.code)}"`
            );
        }
    } else {
        // Standard code block rendering
        const langClass = !inline_styles && block.lang ? ` class="language-${block.lang}"` : '';
        const langAttr = block.lang ? ` data-qd-lang="${block.lang}"` : '';
        replacement = `<pre${getAttr('pre')}${dataQd(block.fence)}${langAttr}><code${langClass}>${block.code}</code></pre>`;
    }
    
    html = html.replace(`${PLACEHOLDER_CB}${i}§`, replacement);
});
```

### 3. Update quikdown_bd.js for Reverse Conversion

```javascript
// In quikdown_bd.js, add the helper functions at module level (after imports):

function isExtendedFencePlugin(plugin) {
  return plugin && typeof plugin === 'object' && typeof plugin.render === 'function';
}

function getFenceReverser(plugin) {
  if (!plugin) return null;
  if (typeof plugin === 'function' && plugin.reverse) return plugin.reverse;
  if (isExtendedFencePlugin(plugin) && plugin.reverse) return plugin.reverse;
  return null;
}

// Modify quikdown_bd function to accept and pass fence_plugin:

function quikdown_bd(markdown, options = {}) {
    // Store the fence_plugin for toMarkdown to use
    quikdown_bd._lastFencePlugin = options.fence_plugin;
    
    // Use core quikdown with bidirectional flag
    return quikdown(markdown, { ...options, bidirectional: true });
}

// Update toMarkdown to accept optional fence_plugin:

quikdown_bd.toMarkdown = function(htmlOrElement, options = {}) {
    // Get fence_plugin from options or last used
    const fence_plugin = options.fence_plugin || quikdown_bd._lastFencePlugin;
    
    // ... existing setup code ...
    
    // In walkNode function, update the pre/div cases:
    
    case 'pre':
    case 'div':
        // Check if this element has a custom reverser
        if (node.hasAttribute('data-qd-has-reverser') && fence_plugin) {
            const reverser = getFenceReverser(fence_plugin);
            
            if (reverser) {
                try {
                    const result = reverser(node);
                    if (result && result.content !== undefined) {
                        const fence = result.fence || node.getAttribute('data-qd-fence') || '```';
                        const lang = result.lang || node.getAttribute('data-qd-lang') || '';
                        return `${fence}${lang ? lang : ''}\n${result.content}\n${fence}\n\n`;
                    }
                } catch (err) {
                    console.warn('Fence reverse handler error:', err);
                    // Fall through to standard handling
                }
            }
        }
        
        // For div elements that might be fence outputs
        if (tag === 'div') {
            // Check for known fence containers (mermaid, svg-container, etc.)
            const className = node.className || '';
            
            // Check for stored source
            const source = node.getAttribute('data-qd-source');
            if (source) {
                const fence = node.getAttribute('data-qd-fence') || '```';
                const lang = node.getAttribute('data-qd-lang') || '';
                
                // Decode HTML entities
                const temp = document.createElement('textarea');
                temp.innerHTML = source;
                const decodedSource = temp.value;
                
                return `${fence}${lang}\n${decodedSource}\n${fence}\n\n`;
            }
            
            // ... rest of existing div handling ...
        }
        
        // For pre elements (standard code blocks)
        if (tag === 'pre') {
            const fence = node.getAttribute('data-qd-fence') || dataQd || '```';
            const lang = node.getAttribute('data-qd-lang') || '';
            
            // First check for data-qd-source
            const source = node.getAttribute('data-qd-source');
            if (source) {
                const temp = document.createElement('textarea');
                temp.innerHTML = source;
                return `${fence}${lang}\n${temp.value}\n${fence}\n\n`;
            }
            
            // Look for code element child
            const codeEl = node.querySelector('code');
            const codeContent = codeEl ? codeEl.textContent : childContent;
            return `${fence}${lang}\n${codeContent.trimEnd()}\n${fence}\n\n`;
        }
        
        break;
```

### 4. Update QuikdownEditor Integration

```javascript
// In quikdown_edit.js, update the render method to pass fence_plugin to toMarkdown:

updateFromPreview() {
    if (this.isUpdating) return;
    
    try {
        this.isUpdating = true;
        const html = this.previewPanel.innerHTML;
        
        // Pass the fence_plugin for proper reverse conversion
        this._markdown = quikdown_bd.toMarkdown(html, {
            fence_plugin: this.createFencePlugin()
        });
        
        // Update source if visible
        if (this.currentMode !== 'preview') {
            this.sourceTextarea.value = this._markdown;
        }
        
        // Trigger change callback
        if (this.options.onChange) {
            this.options.onChange(this._markdown, html);
        }
    } finally {
        this.isUpdating = false;
    }
}

// Update createFencePlugin to handle extended format:

createFencePlugin() {
    // If customFences contains extended plugins, create a composite plugin
    const customFences = this.options.customFences || {};
    
    // Check if any custom fences are extended format
    const hasExtended = Object.values(customFences).some(f => 
        isExtendedFencePlugin(f) || (typeof f === 'function' && f.reverse)
    );
    
    if (hasExtended) {
        // Return extended format composite plugin
        return {
            render: (code, lang) => {
                const customPlugin = customFences[lang];
                if (customPlugin) {
                    const renderer = getFenceRenderer(customPlugin);
                    if (renderer) {
                        return renderer(code, lang);
                    }
                }
                // ... rest of existing createFencePlugin logic ...
            },
            
            reverse: (element) => {
                // Try to determine the language from the element
                const lang = element.getAttribute('data-qd-lang') || 
                            element.className.match(/language-(\w+)/)?.[1] || '';
                
                const customPlugin = customFences[lang];
                if (customPlugin) {
                    const reverser = getFenceReverser(customPlugin);
                    if (reverser) {
                        return reverser(element);
                    }
                }
                
                // Fallback to default extraction
                return null;
            }
        };
    }
    
    // Return simple function format (existing behavior)
    return (code, lang) => {
        // ... existing createFencePlugin logic ...
    };
}
```

## Usage Examples

### Example 1: SVG Fence Plugin with Validation

```javascript
const svgFencePlugin = {
  render: (content, lang) => {
    // Validate SVG
    if (!content.includes('<svg')) {
      content = `<svg xmlns="http://www.w3.org/2000/svg">${content}</svg>`;
    }
    
    // Sanitize for security
    const clean = DOMPurify.sanitize(content, {
      USE_PROFILES: { svg: true, svgFilters: true }
    });
    
    return `<div class="svg-fence">${clean}</div>`;
  },
  
  reverse: (element) => {
    // Extract the SVG element
    const svg = element.querySelector('svg');
    if (!svg) return null;
    
    // Get just the inner content if it's a wrapper SVG
    let content = svg.innerHTML.trim();
    if (svg.getAttribute('xmlns')) {
      content = svg.outerHTML;
    }
    
    return {
      fence: '```',
      lang: 'svg',
      content: content
    };
  }
};

// Usage
const html = quikdown(markdown, {
  fence_plugin: svgFencePlugin
});

// Perfect roundtrip
const backToMd = quikdown_bd.toMarkdown(html, {
  fence_plugin: svgFencePlugin
});
```

### Example 2: Math/KaTeX Plugin

```javascript
const mathPlugin = {
  render: (content, lang) => {
    try {
      const html = katex.renderToString(content, {
        throwOnError: false,
        displayMode: lang === 'math-display'
      });
      
      // Store original for perfect roundtrip
      return `<div class="math-block" data-math-source="${escapeHtml(content)}">${html}</div>`;
    } catch (err) {
      return `<pre class="math-error">Error: ${err.message}\n${content}</pre>`;
    }
  },
  
  reverse: (element) => {
    // Prefer stored source for accuracy
    const source = element.getAttribute('data-math-source');
    if (source) {
      const temp = document.createElement('textarea');
      temp.innerHTML = source;
      return {
        fence: '```',
        lang: element.classList.contains('math-display') ? 'math-display' : 'math',
        content: temp.value
      };
    }
    
    // Fallback: try to extract LaTeX from KaTeX annotation
    const annotation = element.querySelector('annotation[encoding="application/x-tex"]');
    if (annotation) {
      return {
        fence: '```',
        lang: 'math',
        content: annotation.textContent
      };
    }
    
    return null;
  }
};
```

### Example 3: Mermaid Diagrams

```javascript
const mermaidPlugin = {
  render: (content, lang) => {
    // Let mermaid.js process it client-side
    return `<div class="mermaid" data-mermaid-source="${escapeHtml(content)}">${content}</div>`;
  },
  
  reverse: (element) => {
    // Mermaid replaces content, so we need the stored source
    const source = element.getAttribute('data-mermaid-source');
    if (!source) return null;
    
    const temp = document.createElement('textarea');
    temp.innerHTML = source;
    
    return {
      fence: '```',
      lang: 'mermaid',
      content: temp.value
    };
  }
};
```

### Example 4: CSV Table Plugin

```javascript
const csvPlugin = {
  render: (content, lang) => {
    const delimiter = lang === 'tsv' ? '\t' : lang === 'psv' ? '|' : ',';
    const rows = content.trim().split('\n').map(row => {
      // Simple CSV parsing (production would need proper parser)
      return row.split(delimiter).map(cell => cell.trim());
    });
    
    let html = '<table class="csv-table">';
    rows.forEach((row, i) => {
      html += '<tr>';
      const tag = i === 0 ? 'th' : 'td';
      row.forEach(cell => {
        html += `<${tag}>${escapeHtml(cell)}</${tag}>`;
      });
      html += '</tr>';
    });
    html += '</table>';
    
    // Store original for perfect roundtrip
    return `<div class="csv-wrapper" data-csv-source="${escapeHtml(content)}" data-csv-type="${lang}">${html}</div>`;
  },
  
  reverse: (element) => {
    // Prefer stored source
    const source = element.getAttribute('data-csv-source');
    if (source) {
      const type = element.getAttribute('data-csv-type') || 'csv';
      const temp = document.createElement('textarea');
      temp.innerHTML = source;
      
      return {
        fence: '```',
        lang: type,
        content: temp.value
      };
    }
    
    // Fallback: reconstruct from table
    const table = element.querySelector('table');
    if (!table) return null;
    
    const delimiter = element.dataset.csvType === 'tsv' ? '\t' : 
                     element.dataset.csvType === 'psv' ? '|' : ',';
    
    const rows = Array.from(table.querySelectorAll('tr')).map(tr => {
      const cells = Array.from(tr.querySelectorAll('th, td'));
      return cells.map(cell => cell.textContent.trim()).join(delimiter);
    });
    
    return {
      fence: '```',
      lang: element.dataset.csvType || 'csv',
      content: rows.join('\n')
    };
  }
};
```

## Testing Strategy

### 1. Unit Tests for Helper Functions

```javascript
describe('Fence Plugin Helpers', () => {
  test('getFenceRenderer handles all formats', () => {
    const func = (c, l) => '<div>test</div>';
    const obj = { render: (c, l) => '<div>test</div>' };
    
    expect(typeof getFenceRenderer(func)).toBe('function');
    expect(typeof getFenceRenderer(obj)).toBe('function');
    expect(getFenceRenderer(null)).toBe(null);
  });
  
  test('getFenceReverser detects reverse handlers', () => {
    const simple = (c, l) => '<div>test</div>';
    const withReverse = (c, l) => '<div>test</div>';
    withReverse.reverse = (el) => ({ content: 'test' });
    const obj = { 
      render: (c, l) => '<div>test</div>',
      reverse: (el) => ({ content: 'test' })
    };
    
    expect(getFenceReverser(simple)).toBe(null);
    expect(typeof getFenceReverser(withReverse)).toBe('function');
    expect(typeof getFenceReverser(obj)).toBe('function');
  });
});
```

### 2. Integration Tests

```javascript
describe('Bidirectional Fence Plugins', () => {
  test('backwards compatibility - simple function still works', () => {
    const plugin = (content, lang) => `<pre class="custom">${content}</pre>`;
    const html = quikdown('```js\ncode\n```', { fence_plugin: plugin });
    expect(html).toContain('<pre class="custom">code</pre>');
  });
  
  test('roundtrip with extended plugin', () => {
    const plugin = {
      render: (content) => `<div class="widget">${content}</div>`,
      reverse: (el) => ({ 
        fence: '```',
        lang: 'widget',
        content: el.textContent 
      })
    };
    
    const original = '```widget\nHello World\n```';
    const html = quikdown_bd(original, { fence_plugin: plugin });
    const back = quikdown_bd.toMarkdown(html, { fence_plugin: plugin });
    
    expect(back).toBe(original);
  });
  
  test('fallback when no reverse handler', () => {
    const plugin = (content) => `<pre><code>${content}</code></pre>`;
    
    const original = '```\ncode\n```';
    const html = quikdown_bd(original, { fence_plugin: plugin });
    const back = quikdown_bd.toMarkdown(html, { fence_plugin: plugin });
    
    expect(back).toContain('code');  // Content preserved via fallback
  });
});
```

## Migration Guide

### For Library Users

```javascript
// Step 1: Your existing code continues to work unchanged
const myPlugin = (content, lang) => {
  return `<pre class="hljs">${hljs.highlight(content, {language: lang}).value}</pre>`;
};

// Step 2: When ready, add reverse handler for better roundtrip
myPlugin.reverse = (element) => {
  // Extract original code from highlighted HTML
  const code = element.querySelector('code');
  const lang = code?.className.match(/language-(\w+)/)?.[1];
  
  return {
    fence: '```',
    lang: lang || '',
    content: code?.textContent || element.textContent
  };
};

// Step 3: Or convert to object format for cleaner code
const myPlugin = {
  render: (content, lang) => {
    return `<pre class="hljs">${hljs.highlight(content, {language: lang}).value}</pre>`;
  },
  reverse: (element) => {
    // ... same as above
  }
};
```

### For Plugin Authors

```javascript
// Publish plugins that work with all QuikDown versions
export default function createQuikdownPlugin(options) {
  // Return extended format for v1.0.6+
  if (supportsExtendedFormat()) {
    return {
      render: (content, lang) => renderFunction(content, lang, options),
      reverse: (element) => reverseFunction(element, options)
    };
  }
  
  // Return simple function for older versions
  return (content, lang) => renderFunction(content, lang, options);
}

function supportsExtendedFormat() {
  // Check if quikdown supports extended format
  // Could check version or feature detection
  return typeof window !== 'undefined' && 
         window.quikdown && 
         window.quikdown.version >= '1.0.6';
}
```

## Performance Considerations

1. **Zero overhead for existing plugins** - Simple functions go through the same code path
2. **Minimal overhead for extended plugins** - One additional function call to get renderer
3. **Lazy evaluation** - Reverse handlers only called during HTML→Markdown conversion
4. **Efficient fallback** - Uses existing data-qd-source attributes when no reverser

## Security Considerations

1. **No new attack vectors** - Reverse handlers receive DOM elements, not raw HTML
2. **Existing sanitization applies** - Forward renderers still responsible for sanitization
3. **Safe fallback** - When reverse fails, falls back to safe text extraction
4. **No eval or dynamic code** - All handlers are provided at configuration time

## Compatibility Matrix

| QuikDown Version | Simple Function | Function.reverse | Object Format | Notes |
|-----------------|-----------------|------------------|---------------|--------|
| < 1.0.6 | ✅ Works | ✅ Renders* | ✅ Renders** | *reverse ignored, **uses plugin.render if exists |
| 1.0.6+ | ✅ Works | ✅ Full support | ✅ Full support | All features available |

## Implementation Checklist

- [ ] Add helper functions to quikdown.js
- [ ] Update fence block processing in quikdown.js
- [ ] Add reverse handler support to quikdown_bd.js
- [ ] Update QuikdownEditor to pass fence_plugin to toMarkdown
- [ ] Add comprehensive tests
- [ ] Update TypeScript definitions
- [ ] Update API documentation
- [ ] Add examples to documentation
- [ ] Create migration guide

## Rollout Plan

### Phase 1: Core Implementation (1.0.6)
- Implement helper functions
- Update fence processing
- Basic tests

### Phase 2: Editor Integration (1.0.6)
- Update QuikdownEditor
- Test with existing plugins

### Phase 3: Documentation (1.0.6)
- API documentation
- Migration guide
- Example plugins

### Phase 4: Ecosystem (Post 1.0.6)
- Publish example plugins
- Work with plugin authors
- Gather feedback

## Summary

This implementation provides a clean, backwards-compatible way to add bidirectional support to fence plugins. It:

1. **Maintains 100% backwards compatibility** - All existing code continues to work
2. **Provides flexibility** - Three format options for different use cases
3. **Enables rich content** - Perfect roundtrip for SVG, Math, Diagrams, etc.
4. **Follows QuikDown principles** - Small, fast, simple
5. **Graceful degradation** - Always falls back to safe text extraction

The implementation is straightforward, adds minimal code, and opens up powerful new possibilities for custom content handling while preserving QuikDown's simplicity and compatibility.