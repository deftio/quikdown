{"version":3,"file":"quikdown_yaml.umd.min.js","sources":["../src/quikdown_ast.js","../src/quikdown_yaml.js"],"sourcesContent":["/**\n * quikdown_ast - Forgiving markdown to AST parser\n * Converts markdown to a structured Abstract Syntax Tree\n * @param {string} markdown - The markdown source text\n * @param {Object} options - Optional configuration object\n * @returns {Object} - The AST object\n */\n\n// Version will be injected at build time\nconst quikdownVersion = '__QUIKDOWN_VERSION__';\n\n// Safety limit to prevent infinite loops in list parsing\nconst MAX_LOOP_ITERATIONS = 1000;\n\n/**\n * Parse markdown into an AST\n * @param {string} markdown - The markdown source text\n * @param {Object} options - Optional configuration object\n * @returns {Object} - The AST object\n */\nfunction quikdown_ast(markdown, options = {}) {\n    if (!markdown || typeof markdown !== 'string') {\n        return { type: 'document', children: [] };\n    }\n\n    // Normalize line endings (handle CRLF, CR, LF uniformly)\n    let text = markdown.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    const children = parseBlocks(text, options);\n\n    return {\n        type: 'document',\n        children\n    };\n}\n\n/**\n * Parse block-level elements\n */\nfunction parseBlocks(text, options) {\n    const blocks = [];\n    const lines = text.split('\\n');\n    let i = 0;\n\n    while (i < lines.length) {\n        const line = lines[i];\n\n        // Empty line - skip\n        if (line.trim() === '') {\n            i++;\n            continue;\n        }\n\n        // Fenced code block (``` or ~~~)\n        const fenceMatch = line.match(/^(```|~~~)(.*)$/);\n        if (fenceMatch) {\n            const [, openFence, langPart] = fenceMatch;\n            const lang = langPart.trim();\n            const codeLines = [];\n            i++;\n\n            // Find closing fence (forgiving: accept mismatched fences or EOF)\n            while (i < lines.length) {\n                const closingMatch = lines[i].match(/^(```|~~~)\\s*$/);\n                if (closingMatch) {\n                    i++;\n                    break;\n                }\n                codeLines.push(lines[i]);\n                i++;\n            }\n\n            blocks.push({\n                type: 'code_block',\n                lang: lang || null,\n                content: codeLines.join('\\n'),\n                fence: openFence\n            });\n            continue;\n        }\n\n        // Horizontal rule\n        if (/^---+\\s*$/.test(line) || /^\\*\\*\\*+\\s*$/.test(line) || /^___+\\s*$/.test(line)) {\n            blocks.push({ type: 'hr' });\n            i++;\n            continue;\n        }\n\n        // Heading (forgiving: accept #heading without space)\n        const headingMatch = line.match(/^(#{1,6})\\s*(.+?)\\s*#*$/);\n        if (headingMatch) {\n            const [, hashes, content] = headingMatch;\n            blocks.push({\n                type: 'heading',\n                level: hashes.length,\n                children: parseInline(content, options)\n            });\n            i++;\n            continue;\n        }\n\n        // Table (look for separator line)\n        if (line.includes('|')) {\n            const tableResult = tryParseTable(lines, i, options);\n            if (tableResult) {\n                blocks.push(tableResult.node);\n                i = tableResult.nextIndex;\n                continue;\n            }\n        }\n\n        // Blockquote\n        if (line.match(/^>\\s*/)) {\n            const quoteLines = [];\n            while (i < lines.length && lines[i].match(/^>\\s*/)) {\n                quoteLines.push(lines[i].replace(/^>\\s*/, ''));\n                i++;\n            }\n            blocks.push({\n                type: 'blockquote',\n                children: parseBlocks(quoteLines.join('\\n'), options)\n            });\n            continue;\n        }\n\n        // List (ordered or unordered)\n        const listMatch = line.match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+(.*)$/);\n        if (listMatch) {\n            const listResult = parseList(lines, i, options);\n            blocks.push(listResult.node);\n            i = listResult.nextIndex;\n            continue;\n        }\n\n        // Paragraph - collect lines until empty line or block element\n        const paragraphLines = [];\n        while (i < lines.length) {\n            const pLine = lines[i];\n\n            // Stop on empty line\n            if (pLine.trim() === '') break;\n\n            // Stop on block elements\n            if (/^(```|~~~)/.test(pLine)) break;\n            if (/^#{1,6}\\s/.test(pLine)) break;\n            if (/^---+\\s*$/.test(pLine) || /^\\*\\*\\*+\\s*$/.test(pLine) || /^___+\\s*$/.test(pLine)) break;\n            if (/^>\\s*/.test(pLine)) break;\n            if (/^(\\s*)([*\\-+]|\\d+\\.)\\s+/.test(pLine)) break;\n            if (pLine.includes('|') && i + 1 < lines.length && /^\\|?[\\s\\-:|]+\\|?$/.test(lines[i + 1])) break;\n\n            paragraphLines.push(pLine);\n            i++;\n        }\n\n        if (paragraphLines.length > 0) {\n            blocks.push({\n                type: 'paragraph',\n                children: parseInline(paragraphLines.join('\\n'), options)\n            });\n        }\n    }\n\n    return blocks;\n}\n\n/**\n * Try to parse a table starting at the given line\n */\nfunction tryParseTable(lines, startIndex, options) {\n    // Need at least 2 lines (header + separator)\n    if (startIndex + 1 >= lines.length) return null;\n\n    const headerLine = lines[startIndex];\n    const separatorLine = lines[startIndex + 1];\n\n    // Check if separator line is valid\n    if (!/^\\|?[\\s\\-:|]+\\|?$/.test(separatorLine) || !separatorLine.includes('-')) {\n        return null;\n    }\n\n    // Parse header\n    const headerCells = parseTableRow(headerLine);\n    if (headerCells.length === 0) return null;\n\n    // Parse alignments from separator\n    const separatorCells = parseTableRow(separatorLine);\n    const alignments = separatorCells.map(cell => {\n        const trimmed = cell.trim();\n        if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n        if (trimmed.endsWith(':')) return 'right';\n        return 'left';\n    });\n\n    // Parse headers with inline formatting\n    const headers = headerCells.map(cell => parseInline(cell.trim(), options));\n\n    // Parse body rows\n    const rows = [];\n    let i = startIndex + 2;\n    while (i < lines.length) {\n        const rowLine = lines[i];\n        if (!rowLine.includes('|') || rowLine.trim() === '') break;\n\n        const cells = parseTableRow(rowLine);\n        rows.push(cells.map(cell => parseInline(cell.trim(), options)));\n        i++;\n    }\n\n    return {\n        node: {\n            type: 'table',\n            headers,\n            rows,\n            alignments\n        },\n        nextIndex: i\n    };\n}\n\n/**\n * Parse a table row into cells\n */\nfunction parseTableRow(line) {\n    // Handle pipes at start/end or not\n    let trimmed = line.trim();\n    if (trimmed.startsWith('|')) trimmed = trimmed.slice(1);\n    if (trimmed.endsWith('|')) trimmed = trimmed.slice(0, -1);\n    return trimmed.split('|');\n}\n\n/**\n * Parse a list starting at the given line\n */\nfunction parseList(lines, startIndex, options) {\n    const items = [];\n    let i = startIndex;\n    let loopCount = 0;\n\n    // Determine initial list type\n    const firstMatch = lines[i].match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+(.*)$/);\n    const isOrdered = /^\\d+\\./.test(firstMatch[2]);\n    const baseIndent = firstMatch[1].length;\n\n    while (i < lines.length && loopCount < MAX_LOOP_ITERATIONS) {\n        loopCount++;\n        const line = lines[i];\n        const match = line.match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+(.*)$/);\n\n        if (!match) break;\n\n        const [, indent, marker, content] = match;\n        const indentLevel = indent.length;\n\n        // If less indented than base, stop\n        if (indentLevel < baseIndent) break;\n\n        // If same indentation but different list type, stop\n        const itemIsOrdered = /^\\d+\\./.test(marker);\n        if (indentLevel === baseIndent && itemIsOrdered !== isOrdered) break;\n\n        // If more indented, it's a nested list - handle by collecting sub-lines\n        if (indentLevel > baseIndent) {\n            // This is a nested list item, collect and parse as sublist\n            const subLines = [];\n            let subLoopCount = 0;\n            while (i < lines.length && subLoopCount < MAX_LOOP_ITERATIONS) {\n                subLoopCount++;\n                const subLine = lines[i];\n                const subMatch = subLine.match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+/);\n                if (!subMatch) break;\n                if (subMatch[1].length < baseIndent) break;\n                if (subMatch[1].length === baseIndent) break;\n                subLines.push(subLine);\n                i++;\n            }\n\n            if (subLines.length > 0 && items.length > 0) {\n                // Add nested list to last item\n                const nestedResult = parseList(subLines, 0, options);\n                const lastItem = items[items.length - 1];\n                if (!lastItem.children) {\n                    lastItem.children = [];\n                } else if (!Array.isArray(lastItem.children)) {\n                    lastItem.children = [{ type: 'paragraph', children: lastItem.children }];\n                }\n                lastItem.children.push(nestedResult.node);\n            }\n            continue;\n        }\n\n        // Parse list item\n        const itemNode = {\n            type: 'list_item',\n            checked: null,\n            children: null\n        };\n\n        // Check for task list syntax\n        const taskMatch = content.match(/^\\[([x ])\\]\\s*(.*)$/i);\n        if (taskMatch && !isOrdered) {\n            itemNode.checked = taskMatch[1].toLowerCase() === 'x';\n            itemNode.children = parseInline(taskMatch[2], options);\n        } else {\n            itemNode.children = parseInline(content, options);\n        }\n\n        items.push(itemNode);\n        i++;\n    }\n\n    return {\n        node: {\n            type: 'list',\n            ordered: isOrdered,\n            items\n        },\n        nextIndex: i\n    };\n}\n\n/**\n * Parse inline elements\n */\nfunction parseInline(text, options) {\n    if (!text) return [];\n\n    const nodes = [];\n    let remaining = text;\n\n    while (remaining.length > 0) {\n        let matched = false;\n\n        // Line break (1+ trailing spaces or explicit \\n after processing)\n        // Handle inline line breaks (two spaces at end of line or backslash before newline)\n        const brMatch = remaining.match(/^(.+?)(?:  |\\\\\\n|\\n)/);\n        if (brMatch && remaining.includes('\\n')) {\n            const beforeBr = remaining.indexOf('\\n');\n            const beforeText = remaining.slice(0, beforeBr);\n            const afterText = remaining.slice(beforeBr + 1);\n\n            // Check if line break is significant (2+ trailing spaces or backslash)\n            if (beforeText.endsWith('  ') || beforeText.endsWith('\\\\')) {\n                const cleanText = beforeText.replace(/\\\\$/, '').replace(/  +$/, '');\n                if (cleanText) {\n                    nodes.push(...parseInlineContent(cleanText, options));\n                }\n                nodes.push({ type: 'br' });\n                remaining = afterText;\n                matched = true;\n                continue;\n            }\n        }\n\n        // Images: ![alt](url)\n        const imgMatch = remaining.match(/^!\\[([^\\]]*)\\]\\(\\s*([^)\\s]+)\\s*\\)/);\n        if (imgMatch) {\n            nodes.push({\n                type: 'image',\n                alt: imgMatch[1],\n                url: imgMatch[2].trim()  // Forgiving: trim whitespace in URL\n            });\n            remaining = remaining.slice(imgMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Links: [text](url)\n        const linkMatch = remaining.match(/^\\[([^\\]]+)\\]\\(\\s*([^)\\s]+)\\s*\\)/);\n        if (linkMatch) {\n            nodes.push({\n                type: 'link',\n                url: linkMatch[2].trim(),  // Forgiving: trim whitespace in URL\n                children: parseInlineContent(linkMatch[1], options)\n            });\n            remaining = remaining.slice(linkMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Inline code: `code`\n        const codeMatch = remaining.match(/^`([^`]+)`/);\n        if (codeMatch) {\n            nodes.push({\n                type: 'code',\n                value: codeMatch[1]\n            });\n            remaining = remaining.slice(codeMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Bold: **text** or __text__\n        const boldMatch = remaining.match(/^(\\*\\*|__)(.+?)\\1/);\n        if (boldMatch) {\n            nodes.push({\n                type: 'strong',\n                children: parseInlineContent(boldMatch[2], options)\n            });\n            remaining = remaining.slice(boldMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Strikethrough: ~~text~~\n        const strikeMatch = remaining.match(/^~~(.+?)~~/);\n        if (strikeMatch) {\n            nodes.push({\n                type: 'del',\n                children: parseInlineContent(strikeMatch[1], options)\n            });\n            remaining = remaining.slice(strikeMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Italic: *text* or _text_ (not at word boundary for underscores)\n        const emMatch = remaining.match(/^(\\*|_)(?!\\1)(.+?)(?<!\\1)\\1(?!\\1)/);\n        if (emMatch) {\n            nodes.push({\n                type: 'em',\n                children: parseInlineContent(emMatch[2], options)\n            });\n            remaining = remaining.slice(emMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Autolinks: URLs starting with http:// or https://\n        const urlMatch = remaining.match(/^(https?:\\/\\/[^\\s<>\\[\\]]+)/);\n        if (urlMatch) {\n            nodes.push({\n                type: 'link',\n                url: urlMatch[1],\n                children: [{ type: 'text', value: urlMatch[1] }]\n            });\n            remaining = remaining.slice(urlMatch[0].length);\n            matched = true;\n            continue;\n        }\n\n        // Plain text - consume until next potential inline element or end\n        if (!matched) {\n            // Find next potential inline marker\n            const nextMarker = remaining.search(/[`*_~!\\[\\n]|https?:\\/\\//);\n            if (nextMarker === -1) {\n                // No more markers, consume rest as text\n                nodes.push({ type: 'text', value: remaining });\n                break;\n            } else if (nextMarker === 0) {\n                // Current char is a marker but didn't match - consume it as text\n                nodes.push({ type: 'text', value: remaining[0] });\n                remaining = remaining.slice(1);\n            } else {\n                // Consume text up to next marker\n                nodes.push({ type: 'text', value: remaining.slice(0, nextMarker) });\n                remaining = remaining.slice(nextMarker);\n            }\n        }\n    }\n\n    // Merge adjacent text nodes\n    return mergeTextNodes(nodes);\n}\n\n/**\n * Parse inline content (recursive helper for nested inline elements)\n */\nfunction parseInlineContent(text, options) {\n    // For simple nested content, use parseInline\n    // But handle newlines as spaces for inline content\n    const normalized = text.replace(/\\n/g, ' ');\n    return parseInline(normalized, options);\n}\n\n/**\n * Merge adjacent text nodes\n */\nfunction mergeTextNodes(nodes) {\n    const merged = [];\n    for (const node of nodes) {\n        if (node.type === 'text' && merged.length > 0 && merged[merged.length - 1].type === 'text') {\n            merged[merged.length - 1].value += node.value;\n        } else {\n            merged.push(node);\n        }\n    }\n    return merged;\n}\n\n// Attach version\nquikdown_ast.version = quikdownVersion;\n\n// Export for both CommonJS and ES6\n/* istanbul ignore next */\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = quikdown_ast;\n}\n\n// For browser global\n/* istanbul ignore next */\nif (typeof window !== 'undefined') {\n    window.quikdown_ast = quikdown_ast;\n}\n\nexport default quikdown_ast;\n","/**\n * quikdown_yaml - Markdown to YAML converter\n * Converts markdown to YAML via AST\n * @param {string} markdown - The markdown source text\n * @param {Object} options - Optional configuration object\n * @returns {string} - YAML string representation of the AST\n */\n\nimport quikdown_ast from './quikdown_ast.js';\n\n// Version will be injected at build time\nconst quikdownVersion = '__QUIKDOWN_VERSION__';\n\n/**\n * Convert markdown to YAML\n * @param {string} markdown - The markdown source text\n * @param {Object} options - Optional configuration object\n * @returns {string} - YAML string\n */\nfunction quikdown_yaml(markdown, options = {}) {\n    const ast = quikdown_ast(markdown, options);\n    return astToYaml(ast, 0);\n}\n\n/**\n * Convert an AST node to YAML string\n * Minimal YAML serializer - no external dependencies\n * @param {Object|Array|string|number|boolean|null} node - The value to serialize\n * @param {number} indent - Current indentation level\n * @returns {string} - YAML string\n */\nfunction astToYaml(node, indent) {\n    const spaces = '  '.repeat(indent);\n\n    if (node === null || node === undefined) {\n        return 'null';\n    }\n\n    if (typeof node === 'boolean') {\n        return node ? 'true' : 'false';\n    }\n\n    if (typeof node === 'number') {\n        return String(node);\n    }\n\n    if (typeof node === 'string') {\n        return formatYamlString(node);\n    }\n\n    if (Array.isArray(node)) {\n        if (node.length === 0) {\n            return '[]';\n        }\n\n        const lines = [];\n        for (const item of node) {\n            if (typeof item === 'object' && item !== null && !Array.isArray(item)) {\n                // Object item - inline the first property on the same line as dash\n                const props = Object.entries(item);\n                if (props.length > 0) {\n                    const [firstKey, firstValue] = props[0];\n                    const firstValueStr = formatValue(firstValue, indent + 1);\n                    lines.push(`${spaces}- ${firstKey}: ${firstValueStr}`);\n\n                    // Remaining properties\n                    for (let i = 1; i < props.length; i++) {\n                        const [key, value] = props[i];\n                        const valueStr = formatValue(value, indent + 1);\n                        lines.push(`${spaces}  ${key}: ${valueStr}`);\n                    }\n                } else {\n                    lines.push(`${spaces}- {}`);\n                }\n            } else {\n                // Simple value\n                const valueStr = astToYaml(item, indent + 1);\n                lines.push(`${spaces}- ${valueStr}`);\n            }\n        }\n        return '\\n' + lines.join('\\n');\n    }\n\n    if (typeof node === 'object') {\n        const entries = Object.entries(node);\n        if (entries.length === 0) {\n            return '{}';\n        }\n\n        const lines = [];\n        for (const [key, value] of entries) {\n            const valueStr = formatValue(value, indent);\n            lines.push(`${spaces}${key}: ${valueStr}`);\n        }\n        return lines.join('\\n');\n    }\n\n    return String(node);\n}\n\n/**\n * Format a value for YAML (handles nested objects/arrays)\n */\nfunction formatValue(value, indent) {\n    if (value === null || value === undefined) {\n        return 'null';\n    }\n\n    if (typeof value === 'boolean') {\n        return value ? 'true' : 'false';\n    }\n\n    if (typeof value === 'number') {\n        return String(value);\n    }\n\n    if (typeof value === 'string') {\n        return formatYamlString(value);\n    }\n\n    if (Array.isArray(value)) {\n        if (value.length === 0) {\n            return '[]';\n        }\n        return astToYaml(value, indent + 1);\n    }\n\n    if (typeof value === 'object') {\n        // Nested object - format on new lines with increased indent\n        const entries = Object.entries(value);\n        if (entries.length === 0) {\n            return '{}';\n        }\n        return '\\n' + astToYaml(value, indent + 1);\n    }\n\n    return String(value);\n}\n\n/**\n * Format a string for YAML (handle quoting and escaping)\n */\nfunction formatYamlString(str) {\n    // Check if string needs quoting\n    const needsQuoting = (\n        str === '' ||\n        str.includes('\\n') ||\n        str.includes(':') ||\n        str.includes('#') ||\n        str.includes(\"'\") ||\n        str.includes('\"') ||\n        str.startsWith(' ') ||\n        str.endsWith(' ') ||\n        str.startsWith('-') ||\n        str.startsWith('[') ||\n        str.startsWith('{') ||\n        str === 'true' ||\n        str === 'false' ||\n        str === 'null' ||\n        str === 'yes' ||\n        str === 'no' ||\n        str === 'on' ||\n        str === 'off' ||\n        /^\\d+$/.test(str) ||\n        /^\\d+\\.\\d+$/.test(str)\n    );\n\n    if (!needsQuoting) {\n        return str;\n    }\n\n    // Use double quotes and escape special characters\n    if (str.includes('\\n')) {\n        // For multiline strings, use literal block style\n        const escaped = str.replace(/\\n/g, '\\\\n');\n        return `\"${escaped.replace(/\"/g, '\\\\\"')}\"`;\n    }\n\n    // Simple string quoting\n    return `\"${str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n}\n\n// Expose the AST parser for direct access\nquikdown_yaml.parse = quikdown_ast;\n\n// Expose the YAML serializer for direct AST-to-YAML conversion\nquikdown_yaml.stringify = function(ast) {\n    return astToYaml(ast, 0);\n};\n\n// Attach version\nquikdown_yaml.version = quikdownVersion;\n\n// Export for both CommonJS and ES6\n/* istanbul ignore next */\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = quikdown_yaml;\n}\n\n// For browser global\n/* istanbul ignore next */\nif (typeof window !== 'undefined') {\n    window.quikdown_yaml = quikdown_yaml;\n}\n\nexport default quikdown_yaml;\n"],"names":["quikdown_ast","markdown","options","type","children","parseBlocks","replace","text","blocks","lines","split","i","length","line","trim","fenceMatch","match","openFence","langPart","lang","codeLines","push","content","join","fence","test","headingMatch","hashes","level","parseInline","includes","tableResult","tryParseTable","node","nextIndex","quoteLines","listResult","parseList","paragraphLines","pLine","startIndex","headerLine","separatorLine","headerCells","parseTableRow","alignments","map","cell","trimmed","startsWith","endsWith","headers","rows","rowLine","cells","slice","items","loopCount","firstMatch","isOrdered","baseIndent","indent","marker","indentLevel","itemIsOrdered","subLines","subLoopCount","subLine","subMatch","nestedResult","lastItem","Array","isArray","itemNode","checked","taskMatch","toLowerCase","ordered","nodes","remaining","matched","beforeBr","indexOf","beforeText","afterText","cleanText","parseInlineContent","imgMatch","alt","url","linkMatch","codeMatch","value","boldMatch","strikeMatch","emMatch","urlMatch","nextMarker","search","merged","mergeTextNodes","version","module","exports","window","quikdown_yaml","astToYaml","spaces","repeat","String","formatYamlString","item","valueStr","props","Object","entries","firstKey","firstValue","firstValueStr","formatValue","key","str","parse","stringify","ast"],"mappings":"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"}