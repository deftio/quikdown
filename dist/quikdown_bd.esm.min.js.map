{"version":3,"file":"quikdown_bd.esm.min.js","sources":["../src/quikdown_bd.js"],"sourcesContent":["/**\n * quikdown_bd - Bidirectional markdown/HTML converter\n * Standalone version with round-trip conversion support\n * \n * Uses data-qd attributes to preserve original markdown syntax\n * Enables HTML→Markdown conversion for quikdown-generated HTML\n */\n\n// Version - uses same version as core quikdown\nconst VERSION = '__QUIKDOWN_VERSION__';\n\n// Helper to escape HTML (same as core)\nconst ESC_MAP = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\nfunction escapeHtml(text) {\n    return text.replace(/[&<>\"']/g, m => ESC_MAP[m]);\n}\n\n// Modified getAttr that adds data-qd attributes\nfunction createGetAttrBD(inline_styles, styles) {\n    return function(tag, additionalStyle = '', sourceMarker = '') {\n        let attrs = '';\n        \n        // Add data-qd attribute if source marker provided\n        if (sourceMarker) {\n            attrs += ` data-qd=\"${escapeHtml(sourceMarker)}\"`;\n        }\n        \n        // Add style or class\n        if (inline_styles) {\n            const style = styles[tag];\n            if (style || additionalStyle) {\n                const fullStyle = additionalStyle ? (style ? `${style};${additionalStyle}` : additionalStyle) : style;\n                attrs += ` style=\"${fullStyle}\"`;\n            }\n        } else {\n            attrs += ` class=\"quikdown-${tag}\"`;\n        }\n        \n        return attrs;\n    };\n}\n\n/**\n * Enhanced markdown parser with bidirectional support\n * Wraps the core parser and adds data-qd attributes\n */\nfunction quikdown_bd(markdown, options = {}) {\n    if (!markdown || typeof markdown !== 'string') {\n        return '';\n    }\n    \n    const { fence_plugin, inline_styles = false, bidirectional = true } = options;\n    \n    // If not bidirectional mode, process without data-qd attributes\n    if (!bidirectional) {\n        // Process without bidirectional tracking\n        options.bidirectional = false;\n    }\n    \n    // For bidirectional, we need to manually process with source tracking\n    // This is a custom implementation that adds data-qd attributes\n    \n    const QUIKDOWN_STYLES = {\n        h1: 'font-size:2em;font-weight:600;margin:.67em 0;text-align:left',\n        h2: 'font-size:1.5em;font-weight:600;margin:.83em 0',\n        h3: 'font-size:1.25em;font-weight:600;margin:1em 0',\n        h4: 'font-size:1em;font-weight:600;margin:1.33em 0',\n        h5: 'font-size:.875em;font-weight:600;margin:1.67em 0',\n        h6: 'font-size:.85em;font-weight:600;margin:2em 0',\n        pre: 'background:#f4f4f4;padding:10px;border-radius:4px;overflow-x:auto;margin:1em 0',\n        code: 'background:#f0f0f0;padding:2px 4px;border-radius:3px;font-family:monospace',\n        blockquote: 'border-left:4px solid #ddd;margin-left:0;padding-left:1em',\n        table: 'border-collapse:collapse;width:100%;margin:1em 0',\n        th: 'border:1px solid #ddd;padding:8px;background-color:#f2f2f2;font-weight:bold;text-align:left',\n        td: 'border:1px solid #ddd;padding:8px;text-align:left',\n        hr: 'border:none;border-top:1px solid #ddd;margin:1em 0',\n        img: 'max-width:100%;height:auto',\n        a: 'color:#06c;text-decoration:underline',\n        strong: 'font-weight:bold',\n        em: 'font-style:italic',\n        del: 'text-decoration:line-through',\n        ul: 'margin:.5em 0;padding-left:2em',\n        ol: 'margin:.5em 0;padding-left:2em',\n        li: 'margin:.25em 0',\n        'task-item': 'list-style:none',\n        'task-checkbox': 'margin-right:.5em'\n    };\n    \n    const getAttr = createGetAttrBD(inline_styles, QUIKDOWN_STYLES);\n    \n    // Process markdown with source tracking\n    let html = markdown;\n    \n    // Phase 1: Extract and protect code blocks\n    const codeBlocks = [];\n    const inlineCodes = [];\n    \n    // Extract fenced code blocks\n    html = html.replace(/^(```|~~~)([^\\n]*)\\n([\\s\\S]*?)^\\1$/gm, (match, fence, lang, code) => {\n        const placeholder = `§CB${codeBlocks.length}§`;\n        const langTrimmed = lang.trim();\n        \n        // Store raw code if fence_plugin exists, escaped otherwise (matching quikdown.js behavior)\n        if (fence_plugin && typeof fence_plugin === 'function') {\n            codeBlocks.push({\n                fence,\n                lang: langTrimmed,\n                code: code.trimEnd(),\n                custom: true\n            });\n        } else {\n            codeBlocks.push({\n                fence,\n                lang: langTrimmed,\n                code: escapeHtml(code.trimEnd()),\n                custom: false\n            });\n        }\n        return placeholder;\n    });\n    \n    // Extract inline code\n    html = html.replace(/`([^`]+)`/g, (match, code) => {\n        const placeholder = `§IC${inlineCodes.length}§`;\n        inlineCodes.push({\n            code: escapeHtml(code),\n            original: match\n        });\n        return placeholder;\n    });\n    \n    // Escape HTML\n    html = escapeHtml(html);\n    \n    // Process headings with source tracking\n    html = html.replace(/^(#{1,6})\\s+(.+?)\\s*#*$/gm, (match, hashes, content) => {\n        const level = hashes.length;\n        const sourceMarker = hashes;\n        return `<h${level}${getAttr('h' + level, '', sourceMarker)}>${content}</h${level}>`;\n    });\n    \n    // Process bold/italic/strikethrough with source tracking\n    html = html.replace(/\\*\\*(.+?)\\*\\*/g, `<strong${getAttr('strong', '', '**')}>$1</strong>`);\n    html = html.replace(/__(.+?)__/g, `<strong${getAttr('strong', '', '__')}>$1</strong>`);\n    html = html.replace(/(?<!\\*)\\*(?!\\*)(.+?)(?<!\\*)\\*(?!\\*)/g, `<em${getAttr('em', '', '*')}>$1</em>`);\n    html = html.replace(/(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/g, `<em${getAttr('em', '', '_')}>$1</em>`);\n    html = html.replace(/~~(.+?)~~/g, `<del${getAttr('del', '', '~~')}>$1</del>`);\n    \n    // Process blockquotes\n    html = html.replace(/^&gt;\\s+(.+)$/gm, `<blockquote${getAttr('blockquote', '', '>')}>$1</blockquote>`);\n    html = html.replace(/<\\/blockquote>\\n<blockquote[^>]*>/g, '\\n');\n    \n    // Process horizontal rules\n    html = html.replace(/^---+$/gm, `<hr${getAttr('hr', '', '---')}>`);\n    \n    // Process lists (simplified for now)\n    html = processListsBD(html, getAttr, inline_styles);\n    \n    // Process links and images\n    html = html.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, (match, alt, src) => {\n        return `<img${getAttr('img', '', '!')} src=\"${src}\" alt=\"${alt}\" data-qd-alt=\"${escapeHtml(alt)}\" data-qd-src=\"${escapeHtml(src)}\">`;\n    });\n    \n    html = html.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (match, text, href) => {\n        return `<a${getAttr('a', '', '[')} href=\"${href}\" data-qd-text=\"${escapeHtml(text)}\">${text}</a>`;\n    });\n    \n    // Process tables\n    html = processTablesBD(html, getAttr);\n    \n    // Line breaks\n    html = html.replace(/  $/gm, '<br data-qd=\"  \">');\n    \n    // Paragraphs\n    html = html.replace(/\\n\\n+/g, '</p><p>');\n    html = '<p>' + html + '</p>';\n    \n    // Clean up empty paragraphs and unwrap block elements\n    html = html.replace(/<p><\\/p>/g, '');\n    html = html.replace(/<p>(<h[1-6][^>]*>)/g, '$1');\n    html = html.replace(/(<\\/h[1-6]>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<blockquote[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/blockquote>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<ul[^>]*>|<ol[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/ul>|<\\/ol>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<hr[^>]*>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<table[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/table>)<\\/p>/g, '$1');\n    \n    // Restore code blocks\n    codeBlocks.forEach((block, i) => {\n        const placeholder = `§CB${i}§`;\n        let replacement;\n        \n        if (block.custom && fence_plugin) {\n            // Use custom fence plugin with raw code\n            replacement = fence_plugin(block.code, block.lang);\n            // If plugin returns undefined, fall back to default rendering\n            if (replacement === undefined) {\n                // Need to escape the code for default rendering\n                replacement = `<pre${getAttr('pre', '', block.fence)}><code data-qd-lang=\"${block.lang}\">${escapeHtml(block.code)}</code></pre>`;\n            }\n        } else {\n            // Code is already escaped\n            replacement = `<pre${getAttr('pre', '', block.fence)} data-qd-fence=\"${block.fence}\" data-qd-lang=\"${block.lang}\"><code>${block.code}</code></pre>`;\n        }\n        \n        html = html.replace(placeholder, replacement);\n    });\n    \n    // Restore inline codes\n    inlineCodes.forEach((item, i) => {\n        const placeholder = `§IC${i}§`;\n        html = html.replace(placeholder, `<code${getAttr('code', '', '`')}>${item.code}</code>`);\n    });\n    \n    return html.trim();\n}\n\n// Process lists with source tracking\nfunction processListsBD(text, getAttr, inline_styles) {\n    const lines = text.split('\\n');\n    const result = [];\n    let listStack = [];\n    \n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const match = line.match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+(.+)$/);\n        \n        if (match) {\n            const [, indent, marker, content] = match;\n            const level = Math.floor(indent.length / 2);\n            const isOrdered = /^\\d+\\./.test(marker);\n            const listType = isOrdered ? 'ol' : 'ul';\n            const sourceMarker = isOrdered ? '1.' : marker;\n            \n            // Handle task lists\n            let listItemContent = content;\n            let taskAttrs = '';\n            const taskMatch = content.match(/^\\[([x ])\\]\\s+(.*)$/i);\n            if (taskMatch && !isOrdered) {\n                const [, checked, taskContent] = taskMatch;\n                const isChecked = checked.toLowerCase() === 'x';\n                listItemContent = `<input type=\"checkbox\"${getAttr('task-checkbox', '', '[')}${isChecked ? ' checked' : ''}> ${taskContent}`;\n                taskAttrs = getAttr('task-item', '', '- [ ]');\n            }\n            \n            // Close deeper levels\n            while (listStack.length > level + 1) {\n                const list = listStack.pop();\n                result.push(`</${list.type}>`);\n            }\n            \n            // Open new level if needed\n            if (listStack.length === level) {\n                listStack.push({ type: listType, level, marker: sourceMarker });\n                result.push(`<${listType}${getAttr(listType, '', sourceMarker)}>`);\n            }\n            \n            const liAttr = taskAttrs || getAttr('li', '', sourceMarker);\n            result.push(`<li${liAttr}>${listItemContent}</li>`);\n        } else {\n            // Close all lists\n            while (listStack.length > 0) {\n                const list = listStack.pop();\n                result.push(`</${list.type}>`);\n            }\n            result.push(line);\n        }\n    }\n    \n    // Close remaining lists\n    while (listStack.length > 0) {\n        const list = listStack.pop();\n        result.push(`</${list.type}>`);\n    }\n    \n    return result.join('\\n');\n}\n\n// Process tables with source tracking\nfunction processTablesBD(text, getAttr) {\n    const lines = text.split('\\n');\n    const result = [];\n    let inTable = false;\n    let tableLines = [];\n    \n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        \n        if (line.includes('|')) {\n            if (!inTable) {\n                inTable = true;\n                tableLines = [];\n            }\n            tableLines.push(line);\n        } else {\n            if (inTable) {\n                const tableHtml = buildTableBD(tableLines, getAttr);\n                if (tableHtml) {\n                    result.push(tableHtml);\n                } else {\n                    result.push(...tableLines);\n                }\n                inTable = false;\n                tableLines = [];\n            }\n            result.push(lines[i]);\n        }\n    }\n    \n    if (inTable && tableLines.length > 0) {\n        const tableHtml = buildTableBD(tableLines, getAttr);\n        if (tableHtml) {\n            result.push(tableHtml);\n        } else {\n            result.push(...tableLines);\n        }\n    }\n    \n    return result.join('\\n');\n}\n\n// Build table with source tracking\nfunction buildTableBD(lines, getAttr) {\n    if (lines.length < 2) return null;\n    \n    // Find separator\n    let separatorIndex = -1;\n    let alignments = [];\n    \n    for (let i = 1; i < lines.length; i++) {\n        if (/^\\|?[\\s\\-:|]+\\|?$/.test(lines[i]) && lines[i].includes('-')) {\n            separatorIndex = i;\n            const cells = lines[i].replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n            alignments = cells.map(cell => {\n                const trimmed = cell.trim();\n                if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n                if (trimmed.endsWith(':')) return 'right';\n                return 'left';\n            });\n            break;\n        }\n    }\n    \n    if (separatorIndex === -1) return null;\n    \n    let html = `<table${getAttr('table', '', '|')} data-qd-align=\"${alignments.join(',')}\">\\n`;\n    \n    // Headers\n    if (separatorIndex > 0) {\n        html += `<thead${getAttr('thead', '', '|')}>\\n<tr${getAttr('tr', '', '|')}>\\n`;\n        const cells = lines[0].replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n        cells.forEach((cell, i) => {\n            const align = alignments[i] && alignments[i] !== 'left' ? `text-align:${alignments[i]}` : '';\n            html += `<th${getAttr('th', align, '|')} data-qd-align=\"${alignments[i] || 'left'}\">${escapeHtml(cell.trim())}</th>\\n`;\n        });\n        html += '</tr>\\n</thead>\\n';\n    }\n    \n    // Body\n    const bodyLines = lines.slice(separatorIndex + 1);\n    if (bodyLines.length > 0) {\n        html += `<tbody${getAttr('tbody', '', '|')}>\\n`;\n        bodyLines.forEach(line => {\n            html += `<tr${getAttr('tr', '', '|')}>\\n`;\n            const cells = line.replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n            cells.forEach((cell, i) => {\n                const align = alignments[i] && alignments[i] !== 'left' ? `text-align:${alignments[i]}` : '';\n                html += `<td${getAttr('td', align, '|')} data-qd-align=\"${alignments[i] || 'left'}\">${escapeHtml(cell.trim())}</td>\\n`;\n            });\n            html += '</tr>\\n';\n        });\n        html += '</tbody>\\n';\n    }\n    \n    html += '</table>';\n    return html;\n}\n\n/**\n * Convert HTML back to Markdown by walking the DOM tree\n * Uses data-qd attributes when available, falls back to canonical forms\n * Assumes browser environment with DOM API available\n */\nquikdown_bd.toMarkdown = function(htmlOrElement) {\n    // Accept either HTML string or DOM element\n    let container;\n    if (typeof htmlOrElement === 'string') {\n        container = document.createElement('div');\n        container.innerHTML = htmlOrElement;\n    } else if (htmlOrElement instanceof Element) {\n        container = htmlOrElement;\n    } else {\n        return '';\n    }\n    \n    // Walk the DOM tree and reconstruct markdown\n    function walkNode(node, parentContext = {}) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            // Return text content, preserving whitespace where needed\n            return node.textContent;\n        }\n        \n        if (node.nodeType !== Node.ELEMENT_NODE) {\n            return '';\n        }\n        \n        const tag = node.tagName.toLowerCase();\n        const dataQd = node.getAttribute('data-qd');\n        const styles = window.getComputedStyle ? window.getComputedStyle(node) : {};\n        \n        // Process children with context\n        let childContent = '';\n        for (let child of node.childNodes) {\n            childContent += walkNode(child, { parentTag: tag, ...parentContext });\n        }\n        \n        // Determine markdown based on element and attributes\n        switch (tag) {\n            case 'h1':\n            case 'h2':\n            case 'h3':\n            case 'h4':\n            case 'h5':\n            case 'h6':\n                const level = parseInt(tag[1]);\n                const prefix = dataQd || '#'.repeat(level);\n                return `${prefix} ${childContent.trim()}\\n\\n`;\n                \n            case 'strong':\n            case 'b':\n                // Check if it's bold through style too\n                if (styles.fontWeight === 'bold' || styles.fontWeight >= 700 || tag === 'strong' || tag === 'b') {\n                    const boldMarker = dataQd || '**';\n                    return `${boldMarker}${childContent}${boldMarker}`;\n                }\n                return childContent;\n                \n            case 'em':\n            case 'i':\n                // Check for italic through style\n                if (styles.fontStyle === 'italic' || tag === 'em' || tag === 'i') {\n                    const emMarker = dataQd || '*';\n                    return `${emMarker}${childContent}${emMarker}`;\n                }\n                return childContent;\n                \n            case 'del':\n            case 's':\n            case 'strike':\n                const delMarker = dataQd || '~~';\n                return `${delMarker}${childContent}${delMarker}`;\n                \n            case 'code':\n                // Skip if inside pre (handled by pre)\n                if (parentContext.parentTag === 'pre') {\n                    return childContent;\n                }\n                const codeMarker = dataQd || '`';\n                return `${codeMarker}${childContent}${codeMarker}`;\n                \n            case 'pre':\n                const fence = node.getAttribute('data-qd-fence') || dataQd || '```';\n                const lang = node.getAttribute('data-qd-lang') || '';\n                // Look for code element child\n                const codeEl = node.querySelector('code');\n                const codeContent = codeEl ? codeEl.textContent : childContent;\n                return `${fence}${lang}\\n${codeContent.trimEnd()}\\n${fence}\\n\\n`;\n                \n            case 'blockquote':\n                const quoteMarker = dataQd || '>';\n                const lines = childContent.trim().split('\\n');\n                return lines.map(line => `${quoteMarker} ${line}`).join('\\n') + '\\n\\n';\n                \n            case 'hr':\n                const hrMarker = dataQd || '---';\n                return `${hrMarker}\\n\\n`;\n                \n            case 'br':\n                const brMarker = dataQd || '  ';\n                return `${brMarker}\\n`;\n                \n            case 'a':\n                const linkText = node.getAttribute('data-qd-text') || childContent.trim();\n                const href = node.getAttribute('href') || '';\n                // Check for autolinks\n                if (linkText === href && !dataQd) {\n                    return `<${href}>`;\n                }\n                return `[${linkText}](${href})`;\n                \n            case 'img':\n                const alt = node.getAttribute('data-qd-alt') || node.getAttribute('alt') || '';\n                const src = node.getAttribute('data-qd-src') || node.getAttribute('src') || '';\n                const imgMarker = dataQd || '!';\n                return `${imgMarker}[${alt}](${src})`;\n                \n            case 'ul':\n            case 'ol':\n                return walkList(node, tag === 'ol') + '\\n';\n                \n            case 'li':\n                // Handled by list processor\n                return childContent;\n                \n            case 'table':\n                return walkTable(node) + '\\n\\n';\n                \n            case 'p':\n                // Check if it's actually a paragraph or just a wrapper\n                if (childContent.trim()) {\n                    return childContent.trim() + '\\n\\n';\n                }\n                return '';\n                \n            case 'div':\n                // Check if it's a mermaid container\n                if (node.classList && node.classList.contains('mermaid-container')) {\n                    const fence = node.getAttribute('data-qd-fence') || '```';\n                    const lang = node.getAttribute('data-qd-lang') || 'mermaid';\n                    \n                    // First check for data-qd-source attribute\n                    const source = node.getAttribute('data-qd-source');\n                    if (source) {\n                        // Decode HTML entities from the attribute (mainly &quot;)\n                        const temp = document.createElement('textarea');\n                        temp.innerHTML = source;\n                        const code = temp.value;\n                        return `${fence}${lang}\\n${code}\\n${fence}\\n\\n`;\n                    }\n                    \n                    // Fallback: Look for the legacy .mermaid-source element\n                    const sourceElement = node.querySelector('.mermaid-source');\n                    if (sourceElement) {\n                        // Decode HTML entities\n                        const temp = document.createElement('div');\n                        temp.innerHTML = sourceElement.innerHTML;\n                        const code = temp.textContent;\n                        return `${fence}${lang}\\n${code}\\n${fence}\\n\\n`;\n                    }\n                    \n                    // Final fallback: try to extract from the mermaid element (unreliable after rendering)\n                    const mermaidElement = node.querySelector('.mermaid');\n                    if (mermaidElement && mermaidElement.textContent.includes('graph')) {\n                        return `${fence}${lang}\\n${mermaidElement.textContent.trim()}\\n${fence}\\n\\n`;\n                    }\n                }\n                // Check if it's a standalone mermaid diagram (legacy)\n                if (node.classList && node.classList.contains('mermaid')) {\n                    const fence = node.getAttribute('data-qd-fence') || '```';\n                    const lang = node.getAttribute('data-qd-lang') || 'mermaid';\n                    const code = node.textContent.trim();\n                    return `${fence}${lang}\\n${code}\\n${fence}\\n\\n`;\n                }\n                // Pass through other divs\n                return childContent;\n            \n            case 'span':\n                // Pass through container elements\n                return childContent;\n                \n            default:\n                return childContent;\n        }\n    }\n    \n    // Walk list elements\n    function walkList(listNode, isOrdered, depth = 0) {\n        let result = '';\n        let index = 1;\n        const indent = '  '.repeat(depth);\n        \n        for (let child of listNode.children) {\n            if (child.tagName !== 'LI') continue;\n            \n            const dataQd = child.getAttribute('data-qd');\n            let marker = dataQd || (isOrdered ? `${index}.` : '-');\n            \n            // Check for task list checkbox\n            const checkbox = child.querySelector('input[type=\"checkbox\"]');\n            if (checkbox) {\n                const checked = checkbox.checked ? 'x' : ' ';\n                marker = '-';\n                // Get text without the checkbox\n                let text = '';\n                for (let node of child.childNodes) {\n                    if (node.nodeType === Node.TEXT_NODE) {\n                        text += node.textContent;\n                    } else if (node.tagName && node.tagName !== 'INPUT') {\n                        text += walkNode(node);\n                    }\n                }\n                result += `${indent}${marker} [${checked}] ${text.trim()}\\n`;\n            } else {\n                // Check for nested lists\n                let hasNestedList = false;\n                let itemContent = '';\n                \n                for (let node of child.childNodes) {\n                    if (node.tagName === 'UL' || node.tagName === 'OL') {\n                        hasNestedList = true;\n                        itemContent += walkList(node, node.tagName === 'OL', depth + 1);\n                    } else {\n                        itemContent += walkNode(node);\n                    }\n                }\n                \n                result += `${indent}${marker} ${itemContent.trim()}\\n`;\n            }\n            \n            index++;\n        }\n        \n        return result;\n    }\n    \n    // Walk table elements\n    function walkTable(table) {\n        let result = '';\n        const alignData = table.getAttribute('data-qd-align');\n        const alignments = alignData ? alignData.split(',') : [];\n        \n        // Process header\n        const thead = table.querySelector('thead');\n        if (thead) {\n            const headerRow = thead.querySelector('tr');\n            if (headerRow) {\n                const headers = [];\n                for (let th of headerRow.querySelectorAll('th')) {\n                    headers.push(th.textContent.trim());\n                }\n                result += '| ' + headers.join(' | ') + ' |\\n';\n                \n                // Add separator with alignment\n                const separators = headers.map((_, i) => {\n                    const align = alignments[i] || th.getAttribute('data-qd-align') || 'left';\n                    if (align === 'center') return ':---:';\n                    if (align === 'right') return '---:';\n                    return '---';\n                });\n                result += '| ' + separators.join(' | ') + ' |\\n';\n            }\n        }\n        \n        // Process body\n        const tbody = table.querySelector('tbody');\n        if (tbody) {\n            for (let row of tbody.querySelectorAll('tr')) {\n                const cells = [];\n                for (let td of row.querySelectorAll('td')) {\n                    cells.push(td.textContent.trim());\n                }\n                if (cells.length > 0) {\n                    result += '| ' + cells.join(' | ') + ' |\\n';\n                }\n            }\n        }\n        \n        return result.trim();\n    }\n    \n    // Process the DOM tree\n    let markdown = walkNode(container);\n    \n    // Clean up\n    markdown = markdown.replace(/\\n{3,}/g, '\\n\\n'); // Remove excessive newlines\n    markdown = markdown.trim();\n    \n    return markdown;\n};\n\n// Add emitStyles method (same as core)\nquikdown_bd.emitStyles = function(prefix = 'quikdown-', theme = 'light') {\n    // This would generate CSS based on the styles\n    // For now, returning empty string as placeholder\n    // In production, this would generate the full CSS\n    return '';\n};\n\n// Configure method\nquikdown_bd.configure = function(options) {\n    return function(markdown) {\n        return quikdown_bd(markdown, options);\n    };\n};\n\n// Version property\nquikdown_bd.version = VERSION;\n\n// Export for both module and browser\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = quikdown_bd;\n}\n\nif (typeof window !== 'undefined') {\n    window.quikdown_bd = quikdown_bd;\n}\n\nexport default quikdown_bd;"],"names":["ESC_MAP","escapeHtml","text","replace","m","quikdown_bd","markdown","options","fence_plugin","inline_styles","bidirectional","getAttr","styles","tag","additionalStyle","sourceMarker","attrs","style","createGetAttrBD","h1","h2","h3","h4","h5","h6","pre","code","blockquote","table","th","td","hr","img","a","strong","em","del","ul","ol","li","html","codeBlocks","inlineCodes","match","fence","lang","placeholder","length","langTrimmed","trim","push","trimEnd","custom","original","hashes","content","level","lines","split","result","listStack","i","line","indent","marker","Math","floor","isOrdered","test","listType","listItemContent","taskAttrs","taskMatch","checked","taskContent","isChecked","toLowerCase","list","pop","type","liAttr","join","processListsBD","alt","src","href","inTable","tableLines","includes","tableHtml","buildTableBD","processTablesBD","forEach","block","replacement","undefined","item","separatorIndex","alignments","cells","map","cell","trimmed","startsWith","endsWith","align","bodyLines","slice","toMarkdown","htmlOrElement","container","document","createElement","innerHTML","Element","walkNode","node","parentContext","nodeType","Node","TEXT_NODE","textContent","ELEMENT_NODE","tagName","dataQd","getAttribute","window","getComputedStyle","childContent","child","childNodes","parentTag","parseInt","repeat","fontWeight","boldMarker","fontStyle","emMarker","delMarker","codeMarker","codeEl","querySelector","quoteMarker","linkText","walkList","alignData","thead","headerRow","headers","querySelectorAll","_","tbody","row","walkTable","classList","contains","source","temp","value","sourceElement","mermaidElement","listNode","depth","index","children","checkbox","itemContent","emitStyles","prefix","theme","configure","version","module","exports"],"mappings":"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"}