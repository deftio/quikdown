{"version":3,"file":"quikdown_bd.umd.min.js","sources":["../src/quikdown_bd.js"],"sourcesContent":["/**\n * quikdown_bd - Bidirectional markdown/HTML converter\n * Standalone version with round-trip conversion support\n * \n * Uses data-qd attributes to preserve original markdown syntax\n * Enables HTML→Markdown conversion for quikdown-generated HTML\n */\n\n// Version - uses same version as core quikdown\nconst VERSION = '__QUIKDOWN_VERSION__';\n\n// Helper to escape HTML (same as core)\nconst ESC_MAP = {'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};\nfunction escapeHtml(text) {\n    return text.replace(/[&<>\"']/g, m => ESC_MAP[m]);\n}\n\n// Modified getAttr that adds data-qd attributes\nfunction createGetAttrBD(inline_styles, styles) {\n    return function(tag, additionalStyle = '', sourceMarker = '') {\n        let attrs = '';\n        \n        // Add data-qd attribute if source marker provided\n        if (sourceMarker) {\n            attrs += ` data-qd=\"${escapeHtml(sourceMarker)}\"`;\n        }\n        \n        // Add style or class\n        if (inline_styles) {\n            const style = styles[tag];\n            if (style || additionalStyle) {\n                const fullStyle = additionalStyle ? (style ? `${style};${additionalStyle}` : additionalStyle) : style;\n                attrs += ` style=\"${fullStyle}\"`;\n            }\n        } else {\n            attrs += ` class=\"quikdown-${tag}\"`;\n        }\n        \n        return attrs;\n    };\n}\n\n/**\n * Enhanced markdown parser with bidirectional support\n * Wraps the core parser and adds data-qd attributes\n */\nfunction quikdown_bd(markdown, options = {}) {\n    if (!markdown || typeof markdown !== 'string') {\n        return '';\n    }\n    \n    const { fence_plugin, inline_styles = false, bidirectional = true } = options;\n    \n    // If not bidirectional mode, process without data-qd attributes\n    if (!bidirectional) {\n        // Process without bidirectional tracking\n        options.bidirectional = false;\n    }\n    \n    // For bidirectional, we need to manually process with source tracking\n    // This is a custom implementation that adds data-qd attributes\n    \n    const QUIKDOWN_STYLES = {\n        h1: 'font-size:2em;font-weight:600;margin:.67em 0;text-align:left',\n        h2: 'font-size:1.5em;font-weight:600;margin:.83em 0',\n        h3: 'font-size:1.25em;font-weight:600;margin:1em 0',\n        h4: 'font-size:1em;font-weight:600;margin:1.33em 0',\n        h5: 'font-size:.875em;font-weight:600;margin:1.67em 0',\n        h6: 'font-size:.85em;font-weight:600;margin:2em 0',\n        pre: 'background:#f4f4f4;padding:10px;border-radius:4px;overflow-x:auto;margin:1em 0',\n        code: 'background:#f0f0f0;padding:2px 4px;border-radius:3px;font-family:monospace',\n        blockquote: 'border-left:4px solid #ddd;margin-left:0;padding-left:1em',\n        table: 'border-collapse:collapse;width:100%;margin:1em 0',\n        th: 'border:1px solid #ddd;padding:8px;background-color:#f2f2f2;font-weight:bold;text-align:left',\n        td: 'border:1px solid #ddd;padding:8px;text-align:left',\n        hr: 'border:none;border-top:1px solid #ddd;margin:1em 0',\n        img: 'max-width:100%;height:auto',\n        a: 'color:#06c;text-decoration:underline',\n        strong: 'font-weight:bold',\n        em: 'font-style:italic',\n        del: 'text-decoration:line-through',\n        ul: 'margin:.5em 0;padding-left:2em',\n        ol: 'margin:.5em 0;padding-left:2em',\n        li: 'margin:.25em 0',\n        'task-item': 'list-style:none',\n        'task-checkbox': 'margin-right:.5em'\n    };\n    \n    const getAttr = createGetAttrBD(inline_styles, QUIKDOWN_STYLES);\n    \n    // Process markdown with source tracking\n    let html = markdown;\n    \n    // Phase 1: Extract and protect code blocks\n    const codeBlocks = [];\n    const inlineCodes = [];\n    \n    // Extract fenced code blocks\n    html = html.replace(/^(```|~~~)([^\\n]*)\\n([\\s\\S]*?)^\\1$/gm, (match, fence, lang, code) => {\n        const placeholder = `§CB${codeBlocks.length}§`;\n        codeBlocks.push({\n            fence,\n            lang: lang.trim(),\n            code: escapeHtml(code.trimEnd()),\n            original: match\n        });\n        return placeholder;\n    });\n    \n    // Extract inline code\n    html = html.replace(/`([^`]+)`/g, (match, code) => {\n        const placeholder = `§IC${inlineCodes.length}§`;\n        inlineCodes.push({\n            code: escapeHtml(code),\n            original: match\n        });\n        return placeholder;\n    });\n    \n    // Escape HTML\n    html = escapeHtml(html);\n    \n    // Process headings with source tracking\n    html = html.replace(/^(#{1,6})\\s+(.+?)\\s*#*$/gm, (match, hashes, content) => {\n        const level = hashes.length;\n        const sourceMarker = hashes;\n        return `<h${level}${getAttr('h' + level, '', sourceMarker)}>${content}</h${level}>`;\n    });\n    \n    // Process bold/italic/strikethrough with source tracking\n    html = html.replace(/\\*\\*(.+?)\\*\\*/g, `<strong${getAttr('strong', '', '**')}>$1</strong>`);\n    html = html.replace(/__(.+?)__/g, `<strong${getAttr('strong', '', '__')}>$1</strong>`);\n    html = html.replace(/(?<!\\*)\\*(?!\\*)(.+?)(?<!\\*)\\*(?!\\*)/g, `<em${getAttr('em', '', '*')}>$1</em>`);\n    html = html.replace(/(?<!_)_(?!_)(.+?)(?<!_)_(?!_)/g, `<em${getAttr('em', '', '_')}>$1</em>`);\n    html = html.replace(/~~(.+?)~~/g, `<del${getAttr('del', '', '~~')}>$1</del>`);\n    \n    // Process blockquotes\n    html = html.replace(/^&gt;\\s+(.+)$/gm, `<blockquote${getAttr('blockquote', '', '>')}>$1</blockquote>`);\n    html = html.replace(/<\\/blockquote>\\n<blockquote[^>]*>/g, '\\n');\n    \n    // Process horizontal rules\n    html = html.replace(/^---+$/gm, `<hr${getAttr('hr', '', '---')}>`);\n    \n    // Process lists (simplified for now)\n    html = processListsBD(html, getAttr, inline_styles);\n    \n    // Process links and images\n    html = html.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, (match, alt, src) => {\n        return `<img${getAttr('img', '', '!')} src=\"${src}\" alt=\"${alt}\" data-qd-alt=\"${escapeHtml(alt)}\" data-qd-src=\"${escapeHtml(src)}\">`;\n    });\n    \n    html = html.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (match, text, href) => {\n        return `<a${getAttr('a', '', '[')} href=\"${href}\" data-qd-text=\"${escapeHtml(text)}\">${text}</a>`;\n    });\n    \n    // Process tables\n    html = processTablesBD(html, getAttr);\n    \n    // Line breaks\n    html = html.replace(/  $/gm, '<br data-qd=\"  \">');\n    \n    // Paragraphs\n    html = html.replace(/\\n\\n+/g, '</p><p>');\n    html = '<p>' + html + '</p>';\n    \n    // Clean up empty paragraphs and unwrap block elements\n    html = html.replace(/<p><\\/p>/g, '');\n    html = html.replace(/<p>(<h[1-6][^>]*>)/g, '$1');\n    html = html.replace(/(<\\/h[1-6]>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<blockquote[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/blockquote>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<ul[^>]*>|<ol[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/ul>|<\\/ol>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<hr[^>]*>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<table[^>]*>)/g, '$1');\n    html = html.replace(/(<\\/table>)<\\/p>/g, '$1');\n    \n    // Restore code blocks\n    codeBlocks.forEach((block, i) => {\n        const placeholder = `§CB${i}§`;\n        let replacement;\n        \n        if (fence_plugin && typeof fence_plugin === 'function') {\n            replacement = fence_plugin(block.code, block.lang);\n            if (replacement === undefined) {\n                replacement = `<pre${getAttr('pre', '', block.fence)}><code data-qd-lang=\"${block.lang}\">${block.code}</code></pre>`;\n            }\n        } else {\n            replacement = `<pre${getAttr('pre', '', block.fence)} data-qd-fence=\"${block.fence}\" data-qd-lang=\"${block.lang}\"><code>${block.code}</code></pre>`;\n        }\n        \n        html = html.replace(placeholder, replacement);\n    });\n    \n    // Restore inline codes\n    inlineCodes.forEach((item, i) => {\n        const placeholder = `§IC${i}§`;\n        html = html.replace(placeholder, `<code${getAttr('code', '', '`')}>${item.code}</code>`);\n    });\n    \n    return html.trim();\n}\n\n// Process lists with source tracking\nfunction processListsBD(text, getAttr, inline_styles) {\n    const lines = text.split('\\n');\n    const result = [];\n    let listStack = [];\n    \n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const match = line.match(/^(\\s*)([*\\-+]|\\d+\\.)\\s+(.+)$/);\n        \n        if (match) {\n            const [, indent, marker, content] = match;\n            const level = Math.floor(indent.length / 2);\n            const isOrdered = /^\\d+\\./.test(marker);\n            const listType = isOrdered ? 'ol' : 'ul';\n            const sourceMarker = isOrdered ? '1.' : marker;\n            \n            // Handle task lists\n            let listItemContent = content;\n            let taskAttrs = '';\n            const taskMatch = content.match(/^\\[([x ])\\]\\s+(.*)$/i);\n            if (taskMatch && !isOrdered) {\n                const [, checked, taskContent] = taskMatch;\n                const isChecked = checked.toLowerCase() === 'x';\n                listItemContent = `<input type=\"checkbox\"${getAttr('task-checkbox', '', '[')}${isChecked ? ' checked' : ''}> ${taskContent}`;\n                taskAttrs = getAttr('task-item', '', '- [ ]');\n            }\n            \n            // Close deeper levels\n            while (listStack.length > level + 1) {\n                const list = listStack.pop();\n                result.push(`</${list.type}>`);\n            }\n            \n            // Open new level if needed\n            if (listStack.length === level) {\n                listStack.push({ type: listType, level, marker: sourceMarker });\n                result.push(`<${listType}${getAttr(listType, '', sourceMarker)}>`);\n            }\n            \n            const liAttr = taskAttrs || getAttr('li', '', sourceMarker);\n            result.push(`<li${liAttr}>${listItemContent}</li>`);\n        } else {\n            // Close all lists\n            while (listStack.length > 0) {\n                const list = listStack.pop();\n                result.push(`</${list.type}>`);\n            }\n            result.push(line);\n        }\n    }\n    \n    // Close remaining lists\n    while (listStack.length > 0) {\n        const list = listStack.pop();\n        result.push(`</${list.type}>`);\n    }\n    \n    return result.join('\\n');\n}\n\n// Process tables with source tracking\nfunction processTablesBD(text, getAttr) {\n    const lines = text.split('\\n');\n    const result = [];\n    let inTable = false;\n    let tableLines = [];\n    \n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        \n        if (line.includes('|')) {\n            if (!inTable) {\n                inTable = true;\n                tableLines = [];\n            }\n            tableLines.push(line);\n        } else {\n            if (inTable) {\n                const tableHtml = buildTableBD(tableLines, getAttr);\n                if (tableHtml) {\n                    result.push(tableHtml);\n                } else {\n                    result.push(...tableLines);\n                }\n                inTable = false;\n                tableLines = [];\n            }\n            result.push(lines[i]);\n        }\n    }\n    \n    if (inTable && tableLines.length > 0) {\n        const tableHtml = buildTableBD(tableLines, getAttr);\n        if (tableHtml) {\n            result.push(tableHtml);\n        } else {\n            result.push(...tableLines);\n        }\n    }\n    \n    return result.join('\\n');\n}\n\n// Build table with source tracking\nfunction buildTableBD(lines, getAttr) {\n    if (lines.length < 2) return null;\n    \n    // Find separator\n    let separatorIndex = -1;\n    let alignments = [];\n    \n    for (let i = 1; i < lines.length; i++) {\n        if (/^\\|?[\\s\\-:|]+\\|?$/.test(lines[i]) && lines[i].includes('-')) {\n            separatorIndex = i;\n            const cells = lines[i].replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n            alignments = cells.map(cell => {\n                const trimmed = cell.trim();\n                if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n                if (trimmed.endsWith(':')) return 'right';\n                return 'left';\n            });\n            break;\n        }\n    }\n    \n    if (separatorIndex === -1) return null;\n    \n    let html = `<table${getAttr('table', '', '|')} data-qd-align=\"${alignments.join(',')}\">\\n`;\n    \n    // Headers\n    if (separatorIndex > 0) {\n        html += `<thead${getAttr('thead', '', '|')}>\\n<tr${getAttr('tr', '', '|')}>\\n`;\n        const cells = lines[0].replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n        cells.forEach((cell, i) => {\n            const align = alignments[i] && alignments[i] !== 'left' ? `text-align:${alignments[i]}` : '';\n            html += `<th${getAttr('th', align, '|')} data-qd-align=\"${alignments[i] || 'left'}\">${escapeHtml(cell.trim())}</th>\\n`;\n        });\n        html += '</tr>\\n</thead>\\n';\n    }\n    \n    // Body\n    const bodyLines = lines.slice(separatorIndex + 1);\n    if (bodyLines.length > 0) {\n        html += `<tbody${getAttr('tbody', '', '|')}>\\n`;\n        bodyLines.forEach(line => {\n            html += `<tr${getAttr('tr', '', '|')}>\\n`;\n            const cells = line.replace(/^\\|/, '').replace(/\\|$/, '').split('|');\n            cells.forEach((cell, i) => {\n                const align = alignments[i] && alignments[i] !== 'left' ? `text-align:${alignments[i]}` : '';\n                html += `<td${getAttr('td', align, '|')} data-qd-align=\"${alignments[i] || 'left'}\">${escapeHtml(cell.trim())}</td>\\n`;\n            });\n            html += '</tr>\\n';\n        });\n        html += '</tbody>\\n';\n    }\n    \n    html += '</table>';\n    return html;\n}\n\n/**\n * Convert HTML back to Markdown by walking the DOM tree\n * Uses data-qd attributes when available, falls back to canonical forms\n * Assumes browser environment with DOM API available\n */\nquikdown_bd.toMarkdown = function(htmlOrElement) {\n    // Accept either HTML string or DOM element\n    let container;\n    if (typeof htmlOrElement === 'string') {\n        container = document.createElement('div');\n        container.innerHTML = htmlOrElement;\n    } else if (htmlOrElement instanceof Element) {\n        container = htmlOrElement;\n    } else {\n        return '';\n    }\n    \n    // Walk the DOM tree and reconstruct markdown\n    function walkNode(node, parentContext = {}) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            // Return text content, preserving whitespace where needed\n            return node.textContent;\n        }\n        \n        if (node.nodeType !== Node.ELEMENT_NODE) {\n            return '';\n        }\n        \n        const tag = node.tagName.toLowerCase();\n        const dataQd = node.getAttribute('data-qd');\n        const styles = window.getComputedStyle ? window.getComputedStyle(node) : {};\n        \n        // Process children with context\n        let childContent = '';\n        for (let child of node.childNodes) {\n            childContent += walkNode(child, { parentTag: tag, ...parentContext });\n        }\n        \n        // Determine markdown based on element and attributes\n        switch (tag) {\n            case 'h1':\n            case 'h2':\n            case 'h3':\n            case 'h4':\n            case 'h5':\n            case 'h6':\n                const level = parseInt(tag[1]);\n                const prefix = dataQd || '#'.repeat(level);\n                return `${prefix} ${childContent.trim()}\\n\\n`;\n                \n            case 'strong':\n            case 'b':\n                // Check if it's bold through style too\n                if (styles.fontWeight === 'bold' || styles.fontWeight >= 700 || tag === 'strong' || tag === 'b') {\n                    const boldMarker = dataQd || '**';\n                    return `${boldMarker}${childContent}${boldMarker}`;\n                }\n                return childContent;\n                \n            case 'em':\n            case 'i':\n                // Check for italic through style\n                if (styles.fontStyle === 'italic' || tag === 'em' || tag === 'i') {\n                    const emMarker = dataQd || '*';\n                    return `${emMarker}${childContent}${emMarker}`;\n                }\n                return childContent;\n                \n            case 'del':\n            case 's':\n            case 'strike':\n                const delMarker = dataQd || '~~';\n                return `${delMarker}${childContent}${delMarker}`;\n                \n            case 'code':\n                // Skip if inside pre (handled by pre)\n                if (parentContext.parentTag === 'pre') {\n                    return childContent;\n                }\n                const codeMarker = dataQd || '`';\n                return `${codeMarker}${childContent}${codeMarker}`;\n                \n            case 'pre':\n                const fence = node.getAttribute('data-qd-fence') || dataQd || '```';\n                const lang = node.getAttribute('data-qd-lang') || '';\n                // Look for code element child\n                const codeEl = node.querySelector('code');\n                const codeContent = codeEl ? codeEl.textContent : childContent;\n                return `${fence}${lang}\\n${codeContent.trimEnd()}\\n${fence}\\n\\n`;\n                \n            case 'blockquote':\n                const quoteMarker = dataQd || '>';\n                const lines = childContent.trim().split('\\n');\n                return lines.map(line => `${quoteMarker} ${line}`).join('\\n') + '\\n\\n';\n                \n            case 'hr':\n                const hrMarker = dataQd || '---';\n                return `${hrMarker}\\n\\n`;\n                \n            case 'br':\n                const brMarker = dataQd || '  ';\n                return `${brMarker}\\n`;\n                \n            case 'a':\n                const linkText = node.getAttribute('data-qd-text') || childContent.trim();\n                const href = node.getAttribute('href') || '';\n                // Check for autolinks\n                if (linkText === href && !dataQd) {\n                    return `<${href}>`;\n                }\n                return `[${linkText}](${href})`;\n                \n            case 'img':\n                const alt = node.getAttribute('data-qd-alt') || node.getAttribute('alt') || '';\n                const src = node.getAttribute('data-qd-src') || node.getAttribute('src') || '';\n                const imgMarker = dataQd || '!';\n                return `${imgMarker}[${alt}](${src})`;\n                \n            case 'ul':\n            case 'ol':\n                return walkList(node, tag === 'ol') + '\\n';\n                \n            case 'li':\n                // Handled by list processor\n                return childContent;\n                \n            case 'table':\n                return walkTable(node) + '\\n\\n';\n                \n            case 'p':\n                // Check if it's actually a paragraph or just a wrapper\n                if (childContent.trim()) {\n                    return childContent.trim() + '\\n\\n';\n                }\n                return '';\n                \n            case 'div':\n                // Check if it's a mermaid container\n                if (node.classList && node.classList.contains('mermaid-container')) {\n                    const fence = node.getAttribute('data-qd-fence') || '```';\n                    const lang = node.getAttribute('data-qd-lang') || 'mermaid';\n                    // Look for the source element\n                    const sourceElement = node.querySelector('.mermaid-source');\n                    if (sourceElement) {\n                        // Decode HTML entities\n                        const temp = document.createElement('div');\n                        temp.innerHTML = sourceElement.innerHTML;\n                        const code = temp.textContent;\n                        return `${fence}${lang}\\n${code}\\n${fence}\\n\\n`;\n                    }\n                    // Fallback: try to extract from the mermaid element\n                    const mermaidElement = node.querySelector('.mermaid');\n                    if (mermaidElement && mermaidElement.textContent.includes('graph')) {\n                        return `${fence}${lang}\\n${mermaidElement.textContent.trim()}\\n${fence}\\n\\n`;\n                    }\n                }\n                // Check if it's a standalone mermaid diagram (legacy)\n                if (node.classList && node.classList.contains('mermaid')) {\n                    const fence = node.getAttribute('data-qd-fence') || '```';\n                    const lang = node.getAttribute('data-qd-lang') || 'mermaid';\n                    const code = node.textContent.trim();\n                    return `${fence}${lang}\\n${code}\\n${fence}\\n\\n`;\n                }\n                // Pass through other divs\n                return childContent;\n            \n            case 'span':\n                // Pass through container elements\n                return childContent;\n                \n            default:\n                return childContent;\n        }\n    }\n    \n    // Walk list elements\n    function walkList(listNode, isOrdered, depth = 0) {\n        let result = '';\n        let index = 1;\n        const indent = '  '.repeat(depth);\n        \n        for (let child of listNode.children) {\n            if (child.tagName !== 'LI') continue;\n            \n            const dataQd = child.getAttribute('data-qd');\n            let marker = dataQd || (isOrdered ? `${index}.` : '-');\n            \n            // Check for task list checkbox\n            const checkbox = child.querySelector('input[type=\"checkbox\"]');\n            if (checkbox) {\n                const checked = checkbox.checked ? 'x' : ' ';\n                marker = '-';\n                // Get text without the checkbox\n                let text = '';\n                for (let node of child.childNodes) {\n                    if (node.nodeType === Node.TEXT_NODE) {\n                        text += node.textContent;\n                    } else if (node.tagName && node.tagName !== 'INPUT') {\n                        text += walkNode(node);\n                    }\n                }\n                result += `${indent}${marker} [${checked}] ${text.trim()}\\n`;\n            } else {\n                // Check for nested lists\n                let hasNestedList = false;\n                let itemContent = '';\n                \n                for (let node of child.childNodes) {\n                    if (node.tagName === 'UL' || node.tagName === 'OL') {\n                        hasNestedList = true;\n                        itemContent += walkList(node, node.tagName === 'OL', depth + 1);\n                    } else {\n                        itemContent += walkNode(node);\n                    }\n                }\n                \n                result += `${indent}${marker} ${itemContent.trim()}\\n`;\n            }\n            \n            index++;\n        }\n        \n        return result;\n    }\n    \n    // Walk table elements\n    function walkTable(table) {\n        let result = '';\n        const alignData = table.getAttribute('data-qd-align');\n        const alignments = alignData ? alignData.split(',') : [];\n        \n        // Process header\n        const thead = table.querySelector('thead');\n        if (thead) {\n            const headerRow = thead.querySelector('tr');\n            if (headerRow) {\n                const headers = [];\n                for (let th of headerRow.querySelectorAll('th')) {\n                    headers.push(th.textContent.trim());\n                }\n                result += '| ' + headers.join(' | ') + ' |\\n';\n                \n                // Add separator with alignment\n                const separators = headers.map((_, i) => {\n                    const align = alignments[i] || th.getAttribute('data-qd-align') || 'left';\n                    if (align === 'center') return ':---:';\n                    if (align === 'right') return '---:';\n                    return '---';\n                });\n                result += '| ' + separators.join(' | ') + ' |\\n';\n            }\n        }\n        \n        // Process body\n        const tbody = table.querySelector('tbody');\n        if (tbody) {\n            for (let row of tbody.querySelectorAll('tr')) {\n                const cells = [];\n                for (let td of row.querySelectorAll('td')) {\n                    cells.push(td.textContent.trim());\n                }\n                if (cells.length > 0) {\n                    result += '| ' + cells.join(' | ') + ' |\\n';\n                }\n            }\n        }\n        \n        return result.trim();\n    }\n    \n    // Process the DOM tree\n    let markdown = walkNode(container);\n    \n    // Clean up\n    markdown = markdown.replace(/\\n{3,}/g, '\\n\\n'); // Remove excessive newlines\n    markdown = markdown.trim();\n    \n    return markdown;\n};\n\n// Add emitStyles method (same as core)\nquikdown_bd.emitStyles = function(prefix = 'quikdown-', theme = 'light') {\n    // This would generate CSS based on the styles\n    // For now, returning empty string as placeholder\n    // In production, this would generate the full CSS\n    return '';\n};\n\n// Configure method\nquikdown_bd.configure = function(options) {\n    return function(markdown) {\n        return quikdown_bd(markdown, options);\n    };\n};\n\n// Version property\nquikdown_bd.version = VERSION;\n\n// Export for both module and browser\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = quikdown_bd;\n}\n\nif (typeof window !== 'undefined') {\n    window.quikdown_bd = quikdown_bd;\n}\n\nexport default quikdown_bd;"],"names":["ESC_MAP","escapeHtml","text","replace","m","quikdown_bd","markdown","options","fence_plugin","inline_styles","bidirectional","getAttr","styles","tag","additionalStyle","sourceMarker","attrs","style","createGetAttrBD","h1","h2","h3","h4","h5","h6","pre","code","blockquote","table","th","td","hr","img","a","strong","em","del","ul","ol","li","html","codeBlocks","inlineCodes","match","fence","lang","placeholder","length","push","trim","trimEnd","original","hashes","content","level","lines","split","result","listStack","i","line","indent","marker","Math","floor","isOrdered","test","listType","listItemContent","taskAttrs","taskMatch","checked","taskContent","isChecked","toLowerCase","list","pop","type","liAttr","join","processListsBD","alt","src","href","inTable","tableLines","includes","tableHtml","buildTableBD","processTablesBD","forEach","block","replacement","undefined","item","separatorIndex","alignments","cells","map","cell","trimmed","startsWith","endsWith","align","bodyLines","slice","toMarkdown","htmlOrElement","container","document","createElement","innerHTML","Element","walkNode","node","parentContext","nodeType","Node","TEXT_NODE","textContent","ELEMENT_NODE","tagName","dataQd","getAttribute","window","getComputedStyle","childContent","child","childNodes","parentTag","parseInt","repeat","fontWeight","boldMarker","fontStyle","emMarker","delMarker","codeMarker","codeEl","querySelector","quoteMarker","linkText","walkList","alignData","thead","headerRow","headers","querySelectorAll","_","tbody","row","walkTable","classList","contains","sourceElement","temp","mermaidElement","listNode","depth","index","children","checkbox","itemContent","emitStyles","prefix","theme","configure","version","module","exports"],"mappings":"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"}